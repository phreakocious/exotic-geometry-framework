<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="dark">
    <title>Structure Atlas | Exotic Geometry Framework | nullphase</title>
    <meta name="description" content="Explore a 3D phase space projection of data structural fingerprints. Visualize relationships between diverse data domains using exotic geometry metrics and PCA." />
    <meta name="keywords" content="data visualization, phase space projection, structural fingerprinting, PCA, 3D graph, exotic geometry framework, data science, structure atlas" />
    <link rel="canonical" href="https://nullphase.net/sa/" />
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://nullphase.net/sa/" />
    <meta property="og:title" content="Structure Atlas | 3D Data Visualization | nullphase" />
    <meta property="og:description" content="3D projection of data structural fingerprints. Discover hidden relationships in complex data across domains." />
    <meta property="og:image" content="https://nullphase.net/apple-touch-icon.png" />

    <script async src="https://unpkg.com/es-module-shims@1.10.1/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
                "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/controls/OrbitControls.js",
                "three/examples/jsm/renderers/CSS2DRenderer.js": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/renderers/CSS2DRenderer.js"
            }
        }
    </script>
    <style>
        body { margin: 0; background-color: #0a0a0a; color: #ddd; font-family: 'Inter', system-ui, sans-serif; overflow: hidden; }
        canvas { display: block; }
        .glass-card {
            background: rgba(10,10,10,0.4);
            padding: 15px; 
            border-radius: 8px; 
            border: 1px solid #333;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            pointer-events: auto;
        }
        .glass-card a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.2s;
        }
        .glass-card a:hover {
            color: #5dade2;
            text-decoration: underline;
        }
        #ui { position: absolute; top: 20px; left: 20px; z-index: 1000; pointer-events: none; width: 310px; display: flex; flex-direction: column; gap: 10px; transition: transform 0.3s ease; }
        #ui h1 { margin: 0; font-size: 1.3rem; letter-spacing: -0.02em; font-weight: 700; color: #eee; }
        #ui p { margin: 5px 0 0; font-size: 0.8rem; color: #888; line-height: 1.4; }
        
        #legend { 
            position: absolute; 
            bottom: 20px; 
            left: 20px; 
            width: 310px;
            max-height: 40vh; 
            overflow-y: auto;
            z-index: 20;
            transition: transform 0.3s ease;
        }
        
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        #modal-content {
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }
        .modal-close {
            position: sticky;
            top: 0;
            float: right;
            background: #222;
            color: #fff;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
            z-index: 10;
        }
        
        #ui-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(10,10,10,0.85);
            border: 1px solid #111;
            color: #ddd;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: background 0.2s;
        }
        #ui-toggle:hover {
            background: rgba(30,30,30,0.95);
            border-color: #444;
        }

        .ui-hidden #ui { transform: translateX(-150%); }
        .ui-hidden #legend { transform: translateX(-150%); }

        @media (max-width: 600px) {
            #ui, #legend { width: calc(100% - 40px); left: 20px; right: 20px; }
            #legend { max-height: 35vh; }
            #ui { top: 60px; }
            .ui-hidden #ui { transform: translateY(-150%); }
            .ui-hidden #legend { transform: translateY(150%); }
        }
        .legend-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2px 8px;
            margin-bottom: 15px;
        }
        .legend-title {
            grid-column: span 2;
            font-size: 10px; 
            color: #555; 
            text-transform: uppercase; 
            margin-bottom: 10px; 
            border-bottom: 1px solid #222; 
            padding-bottom: 5px;
            letter-spacing: 0.1em;
            font-weight: 700;
        }
        .legend-item { display: flex; align-items: center; font-size: 11px; color: #ccc; }
        .legend-color { width: 10px; height: 10px; border-radius: 2px; margin-right: 8px; flex-shrink: 0; }

                #tooltip { position: absolute; padding: 12px; background: rgba(20,20,20,0.95); border: 1px solid #444; border-radius: 6px; pointer-events: none; display: none; z-index: 100; box-shadow: 0 10px 30px rgba(0,0,0,0.5); transition: opacity 0.1s ease-out, transform 0.1s ease-out; transform: scale(0.95); opacity: 0; }
                
                        #ui-hint {
                            position: fixed;
                            padding: 8px 12px;
                            background: rgba(15, 15, 15, 0.98);
                            color: #ddd;
                            border: 1px solid #333;
                            border-left: 3px solid #3498db;
                            font-size: 11px;
                            border-radius: 4px;
                            pointer-events: none;
                            display: none;
                            z-index: 3000;
                            max-width: 250px;
                            line-height: 1.4;
                            box-shadow: 0 5px 25px rgba(0,0,0,0.8);
                        }        
                #tooltip h3 { margin: 0 0 5px; font-size: 13px; color: #fff; }
        #tooltip div { font-size: 11px; color: #aaa; margin-bottom: 3px; }

        .label { color: #888; font-size: 10px; pointer-events: none; text-shadow: 0 0 4px rgba(0,0,0,0.8); }
        .view-btn {
            background: transparent;
            border: 1px solid #333;
            color: #666;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            padding: 3px 8px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .view-btn:hover { border-color: #555; color: #aaa; }
        .view-btn.active { border-color: #3498db; color: #ddd; background: rgba(52, 152, 219, 0.15); }

        #metric-explorer-toggle { transition: all 0.2s; }
        #metric-explorer-toggle.active { border-color: #e67e22; color: #fff; background: rgba(230, 126, 34, 0.25); }
        #explorer-panel { display: none; margin-top: 8px; }
        #explorer-panel.visible { display: block; }
        #explorer-panel .axis-row { display: flex; align-items: center; gap: 6px; margin-bottom: 6px; }
        #explorer-panel .axis-row label { font-size: 10px; color: #888; font-weight: 700; width: 14px; }
        .metric-select {
            flex: 1; background: #111; color: #ccc; border: 1px solid #333; border-radius: 3px;
            font-size: 10px; padding: 3px 4px; outline: none; max-width: 260px;
        }
        .metric-select:focus { border-color: #e67e22; }
        .metric-select optgroup { color: #888; font-style: normal; }
        .metric-select option { color: #ccc; background: #111; }
        #preset-pills { display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 8px; }
        .preset-pill {
            background: transparent; border: 1px solid #333; color: #666; font-size: 9px;
            padding: 2px 7px; border-radius: 10px; cursor: pointer; transition: all 0.2s; white-space: nowrap;
        }
        .preset-pill:hover { border-color: #555; color: #aaa; }
        .preset-pill.active { border-color: #e67e22; color: #ddd; background: rgba(230, 126, 34, 0.15); }
        #explorer-back { margin-top: 6px; }
        
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: #0a0a0a; z-index: 1000; transition: opacity 0.5s; }
        .loader { width: 48px; height: 48px; border: 3px solid #333; border-bottom-color: #3498db; border-radius: 50%; display: inline-block; box-sizing: border-box; animation: rotation 1s linear infinite; }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="overlay"><span class="loader"></span></div>
    <button id="ui-toggle">Toggle UI</button>
    <div id="ui">
        <div class="glass-card">
            <h1>Structure Atlas</h1>
            <p id="atlas-subtitle">3D phase space projection</p>
            <p style="font-size: 0.75rem; color: #666; line-height: 1.5; margin-top: 8px;">
                <span id="sourceCount" style="color: #ddd;">...</span> data sources from <span id="domainCount" style="color: #ddd;">...</span> <span title="Categories of data origin: chaos, noise, medical, financial, etc." style="border-bottom: 1px dotted #666; cursor: help;">domains</span>.
                Projected from <span id="metricCount" style="color: #ddd;">...</span> <span title="Numerical measurements extracted by each geometry. Each geometry produces multiple metrics that capture different structural properties of the data." style="border-bottom: 1px dotted #666; cursor: help;">metrics</span> across <span id="geomCount" style="color: #ddd;">33</span> <a href="https://github.com/phreakocious/exotic-geometry-framework" target="_blank" title="Mathematical spaces (hyperbolic, symplectic, projective, etc.) used as lenses to reveal hidden structure in byte sequences.">exotic geometries</a> from <span id="sampleSize" style="color: #ddd;">16384</span> uint8 samples.
            </p>
            <div id="status" style="margin-top: 10px; font-size: 11px; color: #3498db;">Initializing...</div>
        </div>

        <div id="controls" class="glass-card">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px;">
                <label style="font-size: 10px; color: #666; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 700;">Labels</label>
                <span id="distVal" style="font-size: 10px; color: #ddd;">40</span>
            </div>
            <input type="range" id="labelDist" min="0" max="150" value="40" style="width: 100%; height: 4px; accent-color: #3498db; margin-bottom: 15px; display: block;">

            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px;">
                <label style="font-size: 10px; color: #666; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 700;" title="Filter data by uniqueness. Low values show only the most unique/isolated sources (outliers) from each domain. High values reveal the dense clusters.">Density</label>
                <span id="densityVal" style="font-size: 10px; color: #ddd;">100%</span>
            </div>
            <input type="range" id="densitySlider" min="0" max="100" value="100" style="width: 100%; height: 4px; accent-color: #9b59b6; margin-bottom: 15px; display: block;">

            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px;">
                <label style="font-size: 10px; color: #666; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 700;" title="Scale the coordinate spread. Higher values push points apart; lower values compress them toward the center.">Scale</label>
                <span id="scaleVal" style="font-size: 10px; color: #ddd;">3.00</span>
            </div>
            <input type="range" id="scaleSlider" min="25" max="2000" value="300" style="width: 100%; height: 4px; accent-color: #2ecc71; margin-bottom: 15px; display: block;">

            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px;">
                <label style="font-size: 10px; color: #666; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 700;" title="Hide sources with low relevance to the current view. Relevance = fraction of the view's metrics where a source scores in the top 10%, discounted for low-complexity (binary/low-entropy) inputs that produce degenerate geometry embeddings. Each view has its own relevance scores.">Relevance</label>
                <span id="relevanceVal" style="font-size: 10px; color: #ddd;">0%</span>
            </div>
            <input type="range" id="relevanceSlider" min="0" max="100" value="0" style="width: 100%; height: 4px; accent-color: #e67e22; margin-bottom: 20px; display: block;">

            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                <span style="font-size: 10px; color: #666; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 700;">Color</span>
                <label style="font-size: 10px; color: #888; cursor: pointer; display: flex; align-items: center; gap: 4px;">
                    <input type="radio" name="colorMode" value="domain" checked style="accent-color: #3498db;"> Domain
                </label>
                <label style="font-size: 10px; color: #888; cursor: pointer; display: flex; align-items: center; gap: 4px;">
                    <input type="radio" name="colorMode" value="cluster" style="accent-color: #e67e22;"> Cluster
                </label>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 12px;">
                <label style="display: flex; align-items: center; gap: 6px; font-size: 10px; color: #888; cursor: pointer;" title="Draw lines connecting all sources from the same data domain.">
                    <input type="checkbox" id="showDomainWebs" style="accent-color: #3498db;"> Domain Webs
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 10px; color: #888; cursor: pointer;" title="Draw lines connecting sources in the same geometric cluster.">
                    <input type="checkbox" id="showClusterWebs" style="accent-color: #e67e22;"> Cluster Webs
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 10px; color: #888; cursor: pointer; grid-column: span 2;" title="Draw vertical lines connecting each data point to the ground plane.">
                    <input type="checkbox" id="showStemLines" checked style="accent-color: #3498db;"> Stem Lines
                </label>
            </div>

            <div id="view-selector" style="display: none; margin-bottom: 12px;">
                <div style="font-size: 10px; color: #666; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 700; margin-bottom: 6px;">View</div>
                <div id="view-buttons" style="display: flex; flex-wrap: wrap; gap: 4px;"></div>
            </div>

            <div style="display: flex; gap: 5px;">
                <input type="file" id="json-upload" accept=".json" style="display: none;">
                <button id="load-json" style="background: #222; border: 1px solid #333; color: #aaa; font-size: 9px; text-transform: uppercase; padding: 6px 4px; border-radius: 3px; cursor: pointer; flex: 1; transition: all 0.2s;" title="Load a custom structure_atlas_data.json file">Load</button>
                <button id="open-catalog" style="background: #222; border: 1px solid #333; color: #aaa; font-size: 9px; text-transform: uppercase; padding: 6px 4px; border-radius: 3px; cursor: pointer; flex: 1; transition: all 0.2s;" title="Browse all exotic geometries">Catalog</button>
                <button id="rotate-view" style="background: #222; border: 1px solid #333; color: #aaa; font-size: 9px; text-transform: uppercase; padding: 6px 4px; border-radius: 3px; cursor: pointer; flex: 1; transition: all 0.2s;" title="Cycle through axis-aligned camera views: XY front, XZ top, YZ side, and isometric corners">Rotate</button>
                <button id="pivot-axes" style="background: #222; border: 1px solid #333; color: #aaa; font-size: 9px; text-transform: uppercase; padding: 6px 4px; border-radius: 3px; cursor: pointer; flex: 1; transition: all 0.2s;" title="Cycle which principal components map to X/Y/Z axes">Pivot</button>
                <button id="metric-explorer-toggle" style="background: #222; border: 1px solid #333; color: #aaa; font-size: 9px; text-transform: uppercase; padding: 6px 4px; border-radius: 3px; cursor: pointer; flex: 1; transition: all 0.2s;" title="Plot sources by any 3 raw metrics (z-scored) instead of PCA">Explore</button>
            </div>
            <div id="explorer-panel">
                <div id="preset-pills"></div>
                <div class="axis-row"><label>X</label><select id="explorer-x" class="metric-select"></select></div>
                <div class="axis-row"><label>Y</label><select id="explorer-y" class="metric-select"></select></div>
                <div class="axis-row"><label>Z</label><select id="explorer-z" class="metric-select"></select></div>
                <button id="explorer-back" style="background: #222; border: 1px solid #333; color: #aaa; font-size: 9px; text-transform: uppercase; padding: 4px 8px; border-radius: 3px; cursor: pointer; width: 100%; transition: all 0.2s;">Back to PCA</button>
            </div>
        </div>

        <div id="character-map" class="glass-card" style="display: flex; flex-direction: column; gap: 15px;">
            <div>
                <label id="pc1-label" style="font-size: 10px; color: #666; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 700;" title="First principal component.">PC1: Distributional Order</label>
                <div style="margin-top: 8px; height: 4px; background: linear-gradient(to right, #00ffff, #3498db, #e74c3c); border-radius: 2px; position: relative;">
                    <div id="pc1-pointer" style="position: absolute; top: -4px; left: 50%; width: 2px; height: 12px; background: white; box-shadow: 0 0 5px white; transition: left 0.2s ease;"></div>
                </div>
                <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 8px; color: #666;">
                    <span id="pc1-min">...</span>
                    <span id="pc1-max">...</span>
                </div>
            </div>

            <div>
                <label id="pc2-label" style="font-size: 10px; color: #666; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 700;" title="Second principal component.">PC2: Spectral Character</label>
                <div style="margin-top: 8px; height: 4px; background: linear-gradient(to right, #2ecc71, #3498db, #9b59b6); border-radius: 2px; position: relative;">
                    <div id="pc2-pointer" style="position: absolute; top: -4px; left: 50%; width: 2px; height: 12px; background: white; box-shadow: 0 0 5px white; transition: left 0.2s ease;"></div>
                </div>
                <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 8px; color: #666;">
                    <span id="pc2-min">...</span>
                    <span id="pc2-max">...</span>
                </div>
            </div>

            <div>
                <label id="pc3-label" style="font-size: 10px; color: #666; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 700;" title="Third principal component.">PC3: Source Formality</label>
                <div style="margin-top: 8px; height: 4px; background: linear-gradient(to right, #f1c40f, #3498db, #1abc9c); border-radius: 2px; position: relative;">
                    <div id="pc3-pointer" style="position: absolute; top: -4px; left: 50%; width: 2px; height: 12px; background: white; box-shadow: 0 0 5px white; transition: left 0.2s ease;"></div>
                </div>
                <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 8px; color: #666;">
                    <span id="pc3-min">...</span>
                    <span id="pc3-max">...</span>
                </div>
            </div>

            <div id="char-label" style="font-size: 11px; color: #888; font-style: italic; text-align: center; border-top: 1px solid #222; padding-top: 10px;">Hover a data source to analyze</div>
        </div>

        <div class="glass-card" style="padding: 10px;">
            <div style="position: relative;">
                <input type="text" id="searchInput" placeholder="Search data sources..."
                    style="width: 100%; background: rgba(0,0,0,0.5); border: 1px solid #333; color: #fff; padding: 10px; padding-right: 30px; border-radius: 4px; font-size: 13px; outline: none; box-sizing: border-box; backdrop-filter: blur(5px);">
                <button id="clearSearch" style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; color: #666; font-size: 18px; cursor: pointer; display: none; padding: 0 5px; transition: color 0.2s;" onmouseover="this.style.color='#fff'" onmouseout="this.style.color='#666'">&times;</button>
            </div>
            <div style="display: flex; align-items: center; gap: 6px; margin-top: 5px;">
                <div id="search-status" style="font-size: 10px; color: #666; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 700; display: none; flex: 1;"></div>
                <button id="searchPrev" style="display: none; background: #222; border: 1px solid #333; color: #aaa; font-size: 11px; padding: 2px 7px; border-radius: 3px; cursor: pointer; line-height: 1;" title="Previous match">&lsaquo;</button>
                <button id="searchNext" style="display: none; background: #222; border: 1px solid #333; color: #aaa; font-size: 11px; padding: 2px 7px; border-radius: 3px; cursor: pointer; line-height: 1;" title="Next match">&rsaquo;</button>
            </div>
        </div>
    </div>
    <div id="legend" class="glass-card"></div>
    <div id="tooltip"></div>
    <div id="ui-hint"></div>

    <div id="modal-overlay">
        <div id="modal-content" class="glass-card">
            <button class="modal-close" id="close-catalog">Close</button>
            <h2 style="margin: 0 0 20px; font-size: 1.2rem; color: #fff; border-bottom: 1px solid #222; padding-bottom: 10px;">Exotic Geometry Catalog</h2>
            <div id="catalog-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px;"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer.js';

        let scene, camera, renderer, labelRenderer, controls, raycaster, mouse;
        let points = [];
        let axisGroup; // Group for axis arrows and labels to allow easy cleanup
        let data = null;
        let geometries = null;

        // Convert snake_case metric names to human-readable form
        function prettifyMetric(s) {
            const special = {
                'chi2_uniformity': 'Chi-Squared Uniformity',
                'ttr': 'Type-Token Ratio',
                'kl_from_uniform': 'KL from Uniform',
                'h1_total_persistence': 'H1 Total Persistence',
                'n_h1_features': 'H1 Features',
                'n_significant_features': 'Significant Features',
                'c3_energy': 'C3 Energy', 'c3_mean': 'C3 Mean',
                'r2': 'R²',
            };
            if (special[s]) return special[s];
            return s.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase())
                    .replace(/\bPc\b/g, 'PC').replace(/\bNn\b/g, 'NN')
                    .replace(/\bR2\b/g, 'R²').replace(/\bD2\b/g, 'D2')
                    .replace(/\bH2\b/g, 'H2').replace(/\bH1\b/g, 'H1');
        }
        let wallXY, wallZY, floor;
        let atlasBounds = null;
        let atlasCenterX = 0, atlasCenterZ = 0;
        let labelThreshold = 40;
        let densityThreshold = 1.0;
        let relevanceThreshold = 0.0;
        let sourceRelevance = [];  // per-source [0, 1] for current view
        let colorMode = 'domain';
        
                let visibleDomains = new Set();
                let visibleClusters = new Set();
                let showDomainWebs = false;
                let showClusterWebs = false;
                let showStemLines = true;
                let domainWebs = {};
                let clusterWebs = {};
                let allClusters = [];
                let currentView = null;
                let savedFullAtlas = null;
                let viewAnimationId = null;
                let unpermutedAxes = null; // axes before pivot permutation

                let searchMatches = [];
                let searchMatchIdx = -1;
                let rotateViewIdx = 0;
                let pivotIdx = 0;

                // Explorer mode state
                let explorerActive = false;
                let explorerZScores = null; // Float64Array[nSources * nMetrics]
                let explorerViewBeforeEnter = null; // view name to restore on exit

                // Perf: shared geometries, camera-change detection, mousemove throttle
                const sharedSphereGeo = new THREE.SphereGeometry(0.5, 24, 24);
                const sharedHitGeo = new THREE.SphereGeometry(1.2, 8, 8);
                let lastCamX = NaN, lastCamY = NaN, lastCamZ = NaN;
                let mouseMoveRafPending = false;
                let pendingMouseEvent = null;
                let cachedTooltipEl = null;
                let lastHoveredName = null;
                const PIVOT_PERMS = [
                    [0, 1, 2],  // PC1→X  PC2→Y  PC3→Z  (default)
                    [1, 2, 0],  // PC2→X  PC3→Y  PC1→Z
                    [2, 0, 1],  // PC3→X  PC1→Y  PC2→Z
                    [0, 2, 1],  // PC1→X  PC3→Y  PC2→Z
                    [2, 1, 0],  // PC3→X  PC2→Y  PC1→Z
                    [1, 0, 2],  // PC2→X  PC1→Y  PC3→Z
                ];

                const status = document.getElementById('status');
                const searchInput = document.getElementById('searchInput');
                const searchStatus = document.getElementById('search-status');
                const searchPrev = document.getElementById('searchPrev');
                const searchNext = document.getElementById('searchNext');
                        let searchAnimationId = null;
                        let currentSearchMatch = null;
                        let currentHoveredPoint = null;
                        
                        let lastCameraPos = new THREE.Vector3();
                        let lastCameraTarget = new THREE.Vector3();
                        
                                function focusOnPoint(source) {
                                    if (searchAnimationId) cancelAnimationFrame(searchAnimationId);
                                    
                                    // Save state if starting new focus
                                    if (!currentSearchMatch) {
                                        lastCameraPos.copy(camera.position);
                                        lastCameraTarget.copy(controls.target);
                                    }
                                    
                                    currentSearchMatch = source;
                                    
                                    const targetPos = new THREE.Vector3(source.pc[0], source.pc[1], source.pc[2]);
                        
            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();
            
            // Calculate a zoom-in position (distance of 15 units)
            const direction = camera.position.clone().sub(controls.target).normalize();
            const endPos = targetPos.clone().add(direction.multiplyScalar(15));
            
            const duration = 800;
            const startTime = performance.now();
            
            function animateSearch(time) {
                const elapsed = time - startTime;
                const t = Math.min(elapsed / duration, 1);
                const ease = t * (2 - t); // easeOutQuad
                
                camera.position.lerpVectors(startPos, endPos, ease);
                controls.target.lerpVectors(startTarget, targetPos, ease);
                controls.update();
                
                if (t < 1) {
                    searchAnimationId = requestAnimationFrame(animateSearch);
                } else {
                    searchAnimationId = null;
                }
            }
            searchAnimationId = requestAnimationFrame(animateSearch);
        }

        const distSlider = document.getElementById('labelDist');
        const distVal = document.getElementById('distVal');
        const densitySlider = document.getElementById('densitySlider');
        const densityVal = document.getElementById('densityVal');
        const relevanceSlider = document.getElementById('relevanceSlider');
        const relevanceValEl = document.getElementById('relevanceVal');
        const scaleSlider = document.getElementById('scaleSlider');
        const scaleValEl = document.getElementById('scaleVal');
        let atlasScale = 3.0;
        let baseSpread = null;   // mean std of global atlas raw PCs (set on data load)
        const TARGET_VISUAL_SPREAD = 5.4;  // baseSpread * default scale (1.8 * 3.0)
        const domainWebToggle = document.getElementById('showDomainWebs');
        const clusterWebToggle = document.getElementById('showClusterWebs');
        const stemLineToggle = document.getElementById('showStemLines');
        const openCatalog = document.getElementById('open-catalog');
        const closeCatalog = document.getElementById('close-catalog');
        const modalOverlay = document.getElementById('modal-overlay');
        const uiHint = document.getElementById('ui-hint');
        const loadJsonBtn = document.getElementById('load-json');
        const jsonUpload = document.getElementById('json-upload');

        loadJsonBtn.addEventListener('click', () => jsonUpload.click());

        // Rotate through canonical camera views
        const rotateViewBtn = document.getElementById('rotate-view');
        const CAMERA_VIEWS = [
            { name: 'Isometric',  pos: [1, 0.6, 1] },
            { name: 'XY Front',   pos: [0, 0, 1] },
            { name: 'XZ Top',     pos: [0, 1, 0.01] },
            { name: 'YZ Side',    pos: [1, 0, 0] },
            { name: 'Iso Back',   pos: [-1, 0.6, -1] },
            { name: 'XY Back',    pos: [0, 0, -1] },
        ];
        rotateViewBtn.addEventListener('click', () => {
            rotateViewIdx = (rotateViewIdx + 1) % CAMERA_VIEWS.length;
            const view = CAMERA_VIEWS[rotateViewIdx];

            // Compute ideal distance from data extent so the cloud fills the view
            const b = atlasBounds;
            const extentX = (b.maxX - b.minX) || 1;
            const extentY = (b.maxY - b.minY) || 1;
            const extentZ = (b.maxZ - b.minZ) || 1;
            const maxExtent = Math.max(extentX, extentY, extentZ);
            const fovRad = camera.fov * Math.PI / 180;
            const dist = (maxExtent / 2) / Math.tan(fovRad / 2) * 1.2; // 1.2x padding

            // Data center
            const center = new THREE.Vector3(
                atlasCenterX, (b.minY + b.maxY) / 2, atlasCenterZ
            );

            // Camera position along the chosen direction
            const dir = new THREE.Vector3(...view.pos).normalize();
            const endPos = center.clone().add(dir.clone().multiplyScalar(dist));

            // Offset rightward to compensate for left UI panel (~330px)
            // Shift = fraction of viewport * visible width at target distance
            const panelPx = 330;
            const viewportW = window.innerWidth;
            const visibleW = 2 * dist * Math.tan(fovRad * camera.aspect / 2);
            const worldShift = (panelPx / viewportW) * visibleW * 0.5;
            // "Right" in screen space = cross(viewDir, up)
            const up = new THREE.Vector3(0, 1, 0);
            const right = new THREE.Vector3().crossVectors(dir, up).normalize();
            if (right.length() < 0.01) right.set(1, 0, 0); // degenerate (top-down)
            const offset = right.clone().multiplyScalar(worldShift);
            endPos.add(offset);
            const endTarget = center.clone().add(offset);

            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();
            const duration = 600;
            const startTime = performance.now();
            let animId = null;
            function animateRotate(time) {
                const t = Math.min((time - startTime) / duration, 1);
                const ease = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                camera.position.lerpVectors(startPos, endPos, ease);
                controls.target.lerpVectors(startTarget, endTarget, ease);
                controls.update();
                if (t < 1) animId = requestAnimationFrame(animateRotate);
            }
            animId = requestAnimationFrame(animateRotate);
            rotateViewBtn.title = `View: ${view.name}. Click to cycle.`;
        });

        // Pivot: cycle which PCs map to X/Y/Z
        const pivotBtn = document.getElementById('pivot-axes');
        pivotBtn.addEventListener('click', () => {
            pivotIdx = (pivotIdx + 1) % PIVOT_PERMS.length;
            const perm = PIVOT_PERMS[pivotIdx];

            // Get the raw (unpermuted) PCs, scaled to current atlasScale
            let rawPCs;
            if (currentView === null) {
                rawPCs = savedFullAtlas.rawPc.map(p => p.slice(0, 3).map(v => v * atlasScale));
            } else {
                rawPCs = data.views[currentView].pc.map(p => p.slice(0, 3).map(v => v * atlasScale));
            }

            // Permute
            const targetPCs = rawPCs.map(p => [p[perm[0]], p[perm[1]], p[perm[2]]]);

            // Animate points
            const startPositions = points.map(p => p.position.clone());
            const duration = 600;
            const startTime = performance.now();
            if (viewAnimationId) cancelAnimationFrame(viewAnimationId);

            function animatePivot(time) {
                const t = Math.min((time - startTime) / duration, 1);
                const ease = t * (2 - t);
                points.forEach((p, i) => {
                    const sx = startPositions[i].x, sy = startPositions[i].y, sz = startPositions[i].z;
                    const tx = targetPCs[i][0], ty = targetPCs[i][1], tz = targetPCs[i][2];
                    p.position.set(sx + (tx - sx) * ease, sy + (ty - sy) * ease, sz + (tz - sz) * ease);
                    if (p.stemLine) {
                        const arr = p.stemLine.geometry.attributes.position.array;
                        arr[0] = p.position.x; arr[1] = p.position.y; arr[2] = p.position.z;
                        arr[4] = p.position.y; // will fix in finishPivot
                        arr[3] = p.position.x; arr[5] = p.position.z;
                        p.stemLine.geometry.attributes.position.needsUpdate = true;
                    }
                });
                if (t < 1) {
                    viewAnimationId = requestAnimationFrame(animatePivot);
                } else {
                    viewAnimationId = null;
                    finishPivot(perm, targetPCs);
                }
            }
            viewAnimationId = requestAnimationFrame(animatePivot);

            const pcNames = perm.map(i => `PC${i + 1}`);
            pivotBtn.title = `Axes: X=${pcNames[0]} Y=${pcNames[1]} Z=${pcNames[2]}. Click to cycle.`;
        });

        function finishPivot(perm, targetPCs) {
            // Update source.pc to the permuted values
            data.sources.forEach((s, i) => { s.pc = [...targetPCs[i]]; });

            // Recompute bounds
            const pc1s = targetPCs.map(p => p[0]);
            const pc2s = targetPCs.map(p => p[1]);
            const pc3s = targetPCs.map(p => p[2]);
            const step = 5;
            atlasBounds = {
                minX: Math.floor((Math.min(...pc1s) - 5) / step) * step,
                maxX: Math.ceil((Math.max(...pc1s) + 5) / step) * step,
                minY: Math.floor((Math.min(...pc2s) - 5) / step) * step,
                maxY: Math.ceil((Math.max(...pc2s) + 5) / step) * step,
                minZ: Math.floor((Math.min(...pc3s) - 5) / step) * step,
                maxZ: Math.ceil((Math.max(...pc3s) + 5) / step) * step,
            };
            atlasCenterX = (atlasBounds.minX + atlasBounds.maxX) / 2;
            atlasCenterZ = (atlasBounds.minZ + atlasBounds.maxZ) / 2;
            const minY = atlasBounds.minY;

            window.pcaRanges = {
                pc1: [Math.min(...pc1s), Math.max(...pc1s)],
                pc2: [Math.min(...pc2s), Math.max(...pc2s)],
                pc3: [Math.min(...pc3s), Math.max(...pc3s)]
            };

            // Rebuild walls + axes
            if (wallXY) scene.remove(wallXY);
            if (wallZY) scene.remove(wallZY);
            if (floor) scene.remove(floor);
            if (axisGroup) axisGroup.clear();

            // Permute axis metadata: map pc1/pc2/pc3 labels to X/Y/Z based on perm
            const baseAxes = unpermutedAxes || savedFullAtlas.axes || {};
            const pcKeys = ['pc1', 'pc2', 'pc3'];
            data.axes = {
                pc1: baseAxes[pcKeys[perm[0]]] || { label: `PC${perm[0]+1}`, variance: 0 },
                pc2: baseAxes[pcKeys[perm[1]]] || { label: `PC${perm[1]+1}`, variance: 0 },
                pc3: baseAxes[pcKeys[perm[2]]] || { label: `PC${perm[2]+1}`, variance: 0 },
            };

            addWalls(data, atlasBounds);
            addAxisLabels(atlasBounds);

            // Fix stem line floor Y
            points.forEach(p => {
                if (p.stemLine) {
                    const arr = p.stemLine.geometry.attributes.position.array;
                    arr[4] = minY;
                    p.stemLine.geometry.attributes.position.needsUpdate = true;
                }
            });

            rebuildWebs();
            updateViewUI(currentView);
            lastCamX = NaN; // Invalidate camera cache
        }

        jsonUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (evt) => {
                try {
                    const newData = JSON.parse(evt.target.result);
                    reloadAtlas(newData);
                } catch (err) {
                    alert('Error parsing JSON: ' + err.message);
                }
            };
            reader.readAsText(file);
            e.target.value = ''; // Reset so same file can be selected again
        });

        // Drag and Drop Support
        let dragCounter = 0;
        const dropOverlay = document.createElement('div');
        dropOverlay.id = 'drop-overlay';
        dropOverlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);z-index:4000;display:none;align-items:center;justify-content:center;backdrop-filter:blur(5px);';
        dropOverlay.innerHTML = '<div style="color:#3498db;font-size:24px;font-weight:700;border:2px dashed #3498db;padding:50px;border-radius:15px;background:rgba(20,20,20,0.9);pointer-events:none;">Drop JSON to Load Atlas</div>';
        document.body.appendChild(dropOverlay);

        window.addEventListener('dragenter', (e) => {
            e.preventDefault();
            dragCounter++;
            dropOverlay.style.display = 'flex';
        });

        window.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dragCounter--;
            if (dragCounter === 0) {
                dropOverlay.style.display = 'none';
            }
        });

        window.addEventListener('dragover', (e) => e.preventDefault());

        window.addEventListener('drop', (e) => {
            e.preventDefault();
            dragCounter = 0;
            dropOverlay.style.display = 'none';
            
            const file = e.dataTransfer.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    try {
                        const newData = JSON.parse(evt.target.result);
                        reloadAtlas(newData);
                    } catch (err) {
                        alert('Error parsing JSON: ' + err.message);
                    }
                };
                reader.readAsText(file);
            }
        });

        function reloadAtlas(newData) {
            // 1. Cleanup Scene
            points.forEach(p => {
                if (p.label && p.label.element && p.label.element.parentNode) {
                    p.label.element.parentNode.removeChild(p.label.element);
                }
                if (p.stemLine) scene.remove(p.stemLine);
                scene.remove(p);
            });
            points = [];
            
            // Remove lines/webs
            Object.values(domainWebs).forEach(w => scene.remove(w));
            Object.values(clusterWebs).forEach(w => scene.remove(w));
            domainWebs = {};
            clusterWebs = {};
            
            // Remove walls/floor
            if (wallXY) scene.remove(wallXY);
            if (wallZY) scene.remove(wallZY);
            if (floor) scene.remove(floor);
            
            // Clear axis group (geometry + labels)
            if (axisGroup) axisGroup.clear();
            
            // 2. Reset Data State
            data = newData;
            // Re-scale if needed (matching init logic)
            data.sources.forEach(s => {
                if (s.pc) s.pc = s.pc.map(v => v * atlasScale);
            });
            
            // Pre-calculate Density Ranks (Per Domain, by Uniqueness/Isolation)
            const sourcesByDomain = {};
            data.sources.forEach(s => {
                if (!sourcesByDomain[s.domain]) sourcesByDomain[s.domain] = [];
                sourcesByDomain[s.domain].push(s);
            });
            
            Object.values(sourcesByDomain).forEach(group => {
                // Sort by nearest neighbor distance (descending) -> Most isolated first
                group.sort((a, b) => {
                    const distA = (a.neighbors && a.neighbors[0]) ? a.neighbors[0].distance : Infinity;
                    const distB = (b.neighbors && b.neighbors[0]) ? b.neighbors[0].distance : Infinity;
                    // Handle Infinity (put first)
                    if (distA === Infinity && distB !== Infinity) return -1;
                    if (distB === Infinity && distA !== Infinity) return 1;
                    return distB - distA;
                });
                
                // Assign rank (0.0 to 1.0)
                group.forEach((s, i) => {
                    s.densityRank = i / Math.max(group.length - 1, 1);
                    s.isTopDog = (i === 0); // Always show the most unique one
                });
            });

            visibleDomains.clear();
            visibleClusters.clear();
            
            // 3. Re-run Init Logic (partial)
            // Update counts
            document.getElementById('sourceCount').textContent = data.sources.length;
            const uniqueDomains = new Set(data.sources.map(s => s.domain));
            document.getElementById('domainCount').textContent = uniqueDomains.size;
            document.getElementById('metricCount').textContent = data.n_metrics || '...';
            
            // Update Visibility Sets
            Object.keys(data.domain_colors).forEach(d => visibleDomains.add(d));
            allClusters = [...new Set(data.sources.map(s => s.cluster))].sort((a, b) => a - b);
            allClusters.forEach(c => visibleClusters.add(c));

            // Reset view state and save full atlas for view switching
            // rawPc stores unscaled coordinates; savedFullAtlas.pc has current scale applied
            currentView = null;
            pivotIdx = 0;
            const rawPc = data.sources.map(s => s.pc.map(v => v / atlasScale));
            baseSpread = meanStd(rawPc);
            savedFullAtlas = {
                pc: data.sources.map(s => [...s.pc]),
                rawPc: rawPc,
                clusters: data.sources.map(s => s.cluster),
                allClusters: [...allClusters],
                axes: data.axes ? JSON.parse(JSON.stringify(data.axes)) : null
            };
            unpermutedAxes = savedFullAtlas.axes;

            // Recalculate Bounds
            const pc1s = data.sources.map(s => s.pc[0]);
            const pc2s = data.sources.map(s => s.pc[1]);
            const pc3s = data.sources.map(s => s.pc[2]);
            const step = 5;
            const minX = Math.floor((Math.min(...pc1s) - 5) / step) * step;
            const maxX = Math.ceil((Math.max(...pc1s) + 5) / step) * step;
            const minY = Math.floor((Math.min(...pc2s) - 5) / step) * step;
            const maxY = Math.ceil((Math.max(...pc2s) + 5) / step) * step;
            const minZ = Math.floor((Math.min(...pc3s) - 5) / step) * step;
            const maxZ = Math.ceil((Math.max(...pc3s) + 5) / step) * step;

            atlasBounds = { minX, maxX, minY, maxY, minZ, maxZ };
            atlasCenterX = (minX + maxX) / 2;
            atlasCenterZ = (minZ + maxZ) / 2;

            // Update Dashboard Ranges
            window.pcaRanges = {
                pc1: [Math.min(...pc1s), Math.max(...pc1s)],
                pc2: [Math.min(...pc2s), Math.max(...pc2s)],
                pc3: [Math.min(...pc3s), Math.max(...pc3s)]
            };
            window.atlasAxes = data.axes || {};
            
            // Re-render Labels (min/max)
            const axes = data.axes || {};
            document.getElementById('pc1-min').textContent = (axes.pc1 && axes.pc1.low) || 'Low';
            document.getElementById('pc1-max').textContent = (axes.pc1 && axes.pc1.high) || 'High';
            // ... (others omitted for brevity, logic is same)

            // Dynamic Label Update (using new logic)
            if (data.axes) {
                ['pc1', 'pc2', 'pc3'].forEach((key, idx) => {
                    const ax = data.axes[key];
                    if (ax) {
                        const pct = (ax.variance * 100).toFixed(1);
                        const shortLabel = ax.label.replace(/^PC\d+:\s*/, '');
                        const el = document.getElementById(`${key}-label`);
                        if (el) {
                            const axisName = ['X', 'Y', 'Z'][idx];
                            el.innerHTML = `<span style="color:#ddd; font-weight:900;">${axisName}</span> <span style="color:#666">/ PC${idx+1}</span>: ${shortLabel} <span style="color:#555">(${pct}%)</span>`;
                            const originalTitle = el.getAttribute('data-original-title') || el.title;
                            if (!el.getAttribute('data-original-title')) el.setAttribute('data-original-title', originalTitle);
                            
                            const varianceRegex = /\(\d+(\.\d+)?% of variance\)/;
                            let newTitle;
                            if (varianceRegex.test(originalTitle)) {
                                newTitle = originalTitle.replace(varianceRegex, `(${pct}% of variance)`);
                            } else {
                                const descPart = originalTitle.replace(/^(First|Second|Third) principal component\.?/, '').trim();
                                newTitle = `PC${idx+1} (${pct}% of variance). ${descPart || ax.description}`;
                            }
                            el.title = newTitle;
                        }
                    }
                });
            }

            // Rebuild Scene Elements
            controls.target.set(atlasCenterX, (minY + maxY) / 2, atlasCenterZ);
            
            // Reset saved state for the new data
            lastCameraPos.copy(camera.position);
            lastCameraTarget.copy(controls.target);
            
            createAtlas(data, atlasBounds.minY);
            addWalls(data, atlasBounds);
            addAxisLabels(atlasBounds);
            createLegend(data);
            buildViewButtons();

            // Initialize relevance from per-source global relevance
            // If data lacks relevance scores (pre-rebuild), default to 1 (all relevant)
            const hasRelevance = data.sources.some(s => s.relevance !== undefined);
            sourceRelevance = data.sources.map(s => hasRelevance ? (s.relevance || 0) : 1);

            // Apply initial density filter (if slider wasn't at 100)
            updatePointVisibility();

            status.textContent = `Loaded ${data.sources.length} sources from file.`;
        }

        function buildViewButtons() {
            const container = document.getElementById('view-buttons');
            const selector = document.getElementById('view-selector');
            container.innerHTML = '';

            if (!data.views || Object.keys(data.views).length === 0) {
                selector.style.display = 'none';
                return;
            }

            selector.style.display = 'block';

            const allBtn = document.createElement('button');
            allBtn.className = 'view-btn active';
            allBtn.textContent = 'All';
            allBtn.dataset.view = 'all';
            allBtn.title = 'Full atlas: all geometries and metrics combined';
            allBtn.addEventListener('click', () => switchView(null));
            container.appendChild(allBtn);

            Object.keys(data.views).sort().forEach(name => {
                const view = data.views[name];
                const btn = document.createElement('button');
                btn.className = 'view-btn';
                btn.textContent = name;
                btn.dataset.view = name;
                btn.title = `${view.question}\n${view.geometries.join(', ')}`;
                btn.addEventListener('click', () => switchView(name));
                container.appendChild(btn);
            });
        }

        function meanStd(pcs) {
            // Mean of per-axis standard deviations for first 3 components
            const n = pcs.length;
            if (n < 2) return 1;
            const sums = [0, 0, 0], sq = [0, 0, 0];
            for (let i = 0; i < n; i++) {
                for (let a = 0; a < 3; a++) {
                    const v = pcs[i][a] || 0;
                    sums[a] += v;
                    sq[a] += v * v;
                }
            }
            let total = 0;
            for (let a = 0; a < 3; a++) {
                const mean = sums[a] / n;
                total += Math.sqrt(sq[a] / n - mean * mean);
            }
            return total / 3;
        }

        function switchView(viewName) {
            if (explorerActive) return; // block view switching while explorer is active
            if (viewName === currentView) return;
            if (viewAnimationId) cancelAnimationFrame(viewAnimationId);
            pivotIdx = 0; // Reset pivot on view change

            // Cancel any active search focus
            if (searchAnimationId) {
                cancelAnimationFrame(searchAnimationId);
                searchAnimationId = null;
            }
            currentSearchMatch = null;

            let targetPCs, targetClusters, targetAllClusters;

            // Auto-scale: normalize spread so all views fill the same visual volume
            let rawPCs;
            if (viewName === null) {
                rawPCs = savedFullAtlas.rawPc.map(p => p.slice(0, 3));
                targetClusters = savedFullAtlas.clusters;
                targetAllClusters = savedFullAtlas.allClusters;
            } else {
                const view = data.views[viewName];
                rawPCs = view.pc.map(p => p.slice(0, 3));
                targetClusters = view.labels;
                targetAllClusters = [...new Set(view.labels)].sort((a, b) => a - b);
            }
            const viewSpread = meanStd(rawPCs);
            if (baseSpread && viewSpread > 1e-6) {
                atlasScale = TARGET_VISUAL_SPREAD / viewSpread;
                scaleSlider.value = Math.round(atlasScale * 100);
                scaleValEl.textContent = atlasScale.toFixed(2);
            }
            targetPCs = rawPCs.map(p => p.map(v => v * atlasScale));

            currentView = viewName;

            // Update relevance for this view
            if (viewName === null) {
                const hasRel = data.sources.some(s => s.relevance !== undefined);
                sourceRelevance = data.sources.map(s => hasRel ? (s.relevance || 0) : 1);
            } else {
                const view = data.views[viewName];
                sourceRelevance = (view.relevance && view.relevance.length > 0)
                    ? view.relevance
                    : data.sources.map(() => 1);
            }
            updatePointVisibility();

            // Update button states
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === (viewName || 'all'));
            });

            // Record start positions
            const startPositions = points.map(p => p.position.clone());

            const duration = 800;
            const startTime = performance.now();

            function animateView(time) {
                const elapsed = time - startTime;
                const t = Math.min(elapsed / duration, 1);
                const ease = t * (2 - t); // easeOutQuad

                points.forEach((p, i) => {
                    const sx = startPositions[i].x, sy = startPositions[i].y, sz = startPositions[i].z;
                    const tx = targetPCs[i][0], ty = targetPCs[i][1], tz = targetPCs[i][2];

                    const x = sx + (tx - sx) * ease;
                    const y = sy + (ty - sy) * ease;
                    const z = sz + (tz - sz) * ease;

                    p.position.set(x, y, z);

                    if (p.stemLine) {
                        const arr = p.stemLine.geometry.attributes.position.array;
                        arr[0] = x; arr[1] = y; arr[2] = z;
                        arr[3] = x; arr[5] = z; // floor X/Z follow point, Y stays
                        p.stemLine.geometry.attributes.position.needsUpdate = true;
                    }
                });

                if (t < 1) {
                    viewAnimationId = requestAnimationFrame(animateView);
                } else {
                    viewAnimationId = null;
                    finishViewSwitch(viewName, targetPCs, targetClusters, targetAllClusters);
                }
            }

            viewAnimationId = requestAnimationFrame(animateView);
        }

        function finishViewSwitch(viewName, targetPCs, targetClusters, targetAllClusters) {
            // Update source data
            data.sources.forEach((s, i) => {
                s.pc = [...targetPCs[i]];
                s.cluster = targetClusters[i];
            });

            allClusters = targetAllClusters;

            // Recompute bounds
            const pc1s = targetPCs.map(p => p[0]);
            const pc2s = targetPCs.map(p => p[1]);
            const pc3s = targetPCs.map(p => p[2]);
            const step = 5;
            const minX = Math.floor((Math.min(...pc1s) - 5) / step) * step;
            const maxX = Math.ceil((Math.max(...pc1s) + 5) / step) * step;
            const minY = Math.floor((Math.min(...pc2s) - 5) / step) * step;
            const maxY = Math.ceil((Math.max(...pc2s) + 5) / step) * step;
            const minZ = Math.floor((Math.min(...pc3s) - 5) / step) * step;
            const maxZ = Math.ceil((Math.max(...pc3s) + 5) / step) * step;

            atlasBounds = { minX, maxX, minY, maxY, minZ, maxZ };
            atlasCenterX = (minX + maxX) / 2;
            atlasCenterZ = (minZ + maxZ) / 2;

            window.pcaRanges = {
                pc1: [Math.min(...pc1s), Math.max(...pc1s)],
                pc2: [Math.min(...pc2s), Math.max(...pc2s)],
                pc3: [Math.min(...pc3s), Math.max(...pc3s)]
            };

            // Remove + recreate walls and axis arrows
            if (wallXY) scene.remove(wallXY);
            if (wallZY) scene.remove(wallZY);
            if (floor) scene.remove(floor);
            if (axisGroup) axisGroup.clear();

            // Set axes metadata: full atlas uses saved axes, views get synthetic axes
            if (viewName === null) {
                data.axes = savedFullAtlas.axes;
                window.atlasAxes = savedFullAtlas.axes || {};
            } else {
                const view = data.views[viewName];
                const vAxes = view.axes || {};
                const axisLabel = (pcKey, idx) => {
                    const ax = vAxes[pcKey];
                    if (ax && ax.top_metric) {
                        return `PC${idx}: ${prettifyMetric(ax.top_metric)}`;
                    }
                    return `PC${idx} (${(view.variance_explained[idx-1]*100).toFixed(0)}%)`;
                };
                data.axes = {
                    pc1: { label: axisLabel('pc1', 1), variance: view.variance_explained[0], low: 'Low', high: 'High' },
                    pc2: { label: axisLabel('pc2', 2), variance: view.variance_explained[1], low: 'Low', high: 'High' },
                    pc3: { label: axisLabel('pc3', 3), variance: view.variance_explained[2], low: 'Low', high: 'High' },
                };
                window.atlasAxes = {}; // no semantic endpoints for character type
            }

            // Save unpermuted axes for pivot reference
            unpermutedAxes = JSON.parse(JSON.stringify(data.axes));

            addWalls(data, atlasBounds);
            addAxisLabels(atlasBounds);

            // Fix stem line floor Y
            points.forEach(p => {
                if (p.stemLine) {
                    const arr = p.stemLine.geometry.attributes.position.array;
                    arr[4] = minY;
                    p.stemLine.geometry.attributes.position.needsUpdate = true;
                }
            });

            // Preserve current camera --- don't reset position or target
            lastCameraPos.copy(camera.position);
            lastCameraTarget.copy(controls.target);

            // Reset cluster visibility
            visibleClusters.clear();
            allClusters.forEach(c => visibleClusters.add(c));

            if (colorMode === 'cluster') updateColors();

            rebuildWebs();
            updateViewUI(viewName);
            createLegend(data);
            updatePointVisibility();
            // Invalidate camera cache so next frame updates walls/labels
            lastCamX = NaN;
        }

        function rebuildWebs() {
            Object.values(domainWebs).forEach(w => scene.remove(w));
            Object.values(clusterWebs).forEach(w => scene.remove(w));
            domainWebs = {};
            clusterWebs = {};

            const pointsByDomain = {};
            const pointsByCluster = {};
            points.forEach(p => {
                const s = p.userData;
                if (!pointsByDomain[s.domain]) pointsByDomain[s.domain] = [];
                if (!pointsByCluster[s.cluster]) pointsByCluster[s.cluster] = [];
                pointsByDomain[s.domain].push(p.position);
                pointsByCluster[s.cluster].push(p.position);
            });

            Object.keys(pointsByDomain).forEach(domain => {
                const positions = pointsByDomain[domain];
                if (positions.length < 2) return;
                const linePts = [];
                for (let i = 0; i < positions.length; i++)
                    for (let j = i + 1; j < positions.length; j++)
                        linePts.push(positions[i].clone(), positions[j].clone());
                const webGeo = new THREE.BufferGeometry().setFromPoints(linePts);
                const webMat = new THREE.LineBasicMaterial({
                    color: data.domain_colors[domain], transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending
                });
                const web = new THREE.LineSegments(webGeo, webMat);
                web.visible = showDomainWebs && visibleDomains.has(domain);
                scene.add(web);
                domainWebs[domain] = web;
            });

            Object.keys(pointsByCluster).forEach(cluster => {
                const positions = pointsByCluster[cluster];
                if (positions.length < 2) return;
                const linePts = [];
                for (let i = 0; i < positions.length; i++)
                    for (let j = i + 1; j < positions.length; j++)
                        linePts.push(positions[i].clone(), positions[j].clone());
                const webGeo = new THREE.BufferGeometry().setFromPoints(linePts);
                const webMat = new THREE.LineBasicMaterial({
                    color: getClusterColor(cluster), transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending
                });
                const web = new THREE.LineSegments(webGeo, webMat);
                web.visible = showClusterWebs && visibleClusters.has(parseInt(cluster));
                scene.add(web);
                clusterWebs[cluster] = web;
            });
        }

        function updateViewUI(viewName) {
            const subtitle = document.getElementById('atlas-subtitle');

            if (viewName === null) {
                subtitle.textContent = '3D phase space projection';
                document.getElementById('metricCount').textContent = data.n_metrics || '...';
                document.getElementById('geomCount').textContent = geometries ? geometries.length : (data.n_geometries || 33);

                const axes = data.axes || {};
                ['pc1', 'pc2', 'pc3'].forEach((key, idx) => {
                    const ax = axes[key];
                    const el = document.getElementById(`${key}-label`);
                    if (el && ax) {
                        const pct = (ax.variance * 100).toFixed(1);
                        const shortLabel = ax.label.replace(/^PC\d+:\s*/, '');
                        const match = ax.label.match(/^PC(\d+)/);
                        const pcNum = match ? match[1] : (idx + 1);
                        const axisName = ['X', 'Y', 'Z'][idx];
                        el.innerHTML = `<span style="color:#ddd; font-weight:900;">${axisName}</span> <span style="color:#666">/ PC${pcNum}</span>: ${shortLabel} <span style="color:#555">(${pct}%)</span>`;
                        el.title = `PC${pcNum} (${pct}% of variance). ${ax.description || shortLabel}`;
                    }
                    document.getElementById(`${key}-min`).textContent = (axes[key] && axes[key].low) || 'Low';
                    document.getElementById(`${key}-max`).textContent = (axes[key] && axes[key].high) || 'High';
                });
            } else {
                const view = data.views[viewName];
                subtitle.innerHTML = `<span style="color:#ddd">${viewName}</span> lens: ${view.question}`;
                document.getElementById('metricCount').textContent = view.n_metrics;
                document.getElementById('geomCount').textContent = view.geometries.length;

                // data.axes has synthetic axes set by finishViewSwitch
                const axes = data.axes || {};
                const vAxes = view.axes || {};
                ['pc1', 'pc2', 'pc3'].forEach((key, idx) => {
                    const ax = axes[key];
                    const el = document.getElementById(`${key}-label`);
                    if (el && ax) {
                        const pct = (ax.variance * 100).toFixed(1);
                        const shortLabel = ax.label.replace(/^PC\d+:\s*/, '');
                        const match = ax.label.match(/^PC(\d+)/);
                        const pcNum = match ? match[1] : (idx + 1);
                        const axisName = ['X', 'Y', 'Z'][idx];
                        el.innerHTML = `<span style="color:#ddd; font-weight:900;">${axisName}</span> <span style="color:#666">/ PC${pcNum}</span>: ${shortLabel} <span style="color:#555">(${pct}%)</span>`;
                        const vAx = vAxes[key] || {};
                        const geo = vAx.top_geometry || '';
                        const met = vAx.top_metric ? prettifyMetric(vAx.top_metric) : shortLabel;
                        el.title = `${viewName} lens PC${pcNum} (${pct}% of variance). Top loading: ${met}${geo ? ' (' + geo + ')' : ''}`;
                    }
                    document.getElementById(`${key}-min`).textContent = 'Low';
                    document.getElementById(`${key}-max`).textContent = 'High';
                });
            }
        }

        // Fast UI Hints implementation
        document.addEventListener('mouseover', (e) => {
            const target = e.target.closest('[title]');
            if (target && target.id !== 'ui-toggle') { // Ignore the toggle button
                const text = target.getAttribute('title');
                target.setAttribute('data-title', text);
                target.removeAttribute('title');
                
                uiHint.textContent = text;
                uiHint.style.display = 'block';
                
                const rect = target.getBoundingClientRect();
                uiHint.style.left = (rect.left + rect.width + 10) + 'px';
                uiHint.style.top = rect.top + 'px';
                
                // Adjust if off-screen
                const hintRect = uiHint.getBoundingClientRect();
                if (hintRect.right > window.innerWidth) {
                    uiHint.style.left = (rect.left - hintRect.width - 10) + 'px';
                }
            }
        });

        document.addEventListener('mouseout', (e) => {
            const target = e.target.closest('[data-title]');
            if (target) {
                target.setAttribute('title', target.getAttribute('data-title'));
                target.removeAttribute('data-title');
                uiHint.style.display = 'none';
            }
        });

        distSlider.addEventListener('input', (e) => {
            labelThreshold = parseFloat(e.target.value);
            distVal.textContent = labelThreshold;
        });
        
        densitySlider.addEventListener('input', (e) => {
            densityThreshold = parseFloat(e.target.value) / 100.0;
            densityVal.textContent = e.target.value + '%';
            updatePointVisibility();
        });

        relevanceSlider.addEventListener('input', (e) => {
            relevanceThreshold = parseFloat(e.target.value) / 100.0;
            relevanceValEl.textContent = e.target.value + '%';
            updatePointVisibility();
        });

        scaleSlider.addEventListener('input', (e) => {
            const newScale = parseFloat(e.target.value) / 100.0;
            scaleValEl.textContent = newScale.toFixed(2);
            const ratio = newScale / atlasScale;
            atlasScale = newScale;

            // Rescale all point positions from center
            points.forEach((p, i) => {
                p.position.multiplyScalar(ratio);
                if (p.stemLine) {
                    const arr = p.stemLine.geometry.attributes.position.array;
                    arr[0] = p.position.x; arr[1] = p.position.y; arr[2] = p.position.z;
                    arr[3] = p.position.x; arr[4] *= ratio; arr[5] = p.position.z;
                    p.stemLine.geometry.attributes.position.needsUpdate = true;
                }
                // Keep source.pc in sync
                data.sources[i].pc = [p.position.x, p.position.y, p.position.z];
            });

            // Rescale bounds, walls, axes
            atlasBounds.minX *= ratio; atlasBounds.maxX *= ratio;
            atlasBounds.minY *= ratio; atlasBounds.maxY *= ratio;
            atlasBounds.minZ *= ratio; atlasBounds.maxZ *= ratio;
            atlasCenterX *= ratio;
            atlasCenterZ *= ratio;

            if (wallXY) scene.remove(wallXY);
            if (wallZY) scene.remove(wallZY);
            if (floor) scene.remove(floor);
            if (axisGroup) axisGroup.clear();
            addWalls(data, atlasBounds);
            addAxisLabels(atlasBounds);
            rebuildWebs();
            lastCamX = NaN;
        });

        domainWebToggle.addEventListener('change', (e) => {
            showDomainWebs = e.target.checked;
            updateWebVisibility();
        });

        clusterWebToggle.addEventListener('change', (e) => {
            showClusterWebs = e.target.checked;
            updateWebVisibility();
        });

        stemLineToggle.addEventListener('change', (e) => {
            showStemLines = e.target.checked;
            updatePointVisibility();
        });

        document.getElementsByName('colorMode').forEach(r => {
            r.addEventListener('change', (e) => {
                colorMode = e.target.value;
                updateColors();
            });
        });

        const clusterPalette = ['#e67e22', '#f1c40f', '#2ecc71', '#3498db', '#9b59b6', '#1abc9c', '#e74c3c', '#fd79a8'];

        function getClusterColor(cId) {
            const idx = allClusters.indexOf(parseInt(cId));
            const color = clusterPalette[idx % clusterPalette.length] || '#888888';
            return color;
        }

        function updateColors() {
            points.forEach(p => {
                let color;
                if (colorMode === 'domain') {
                    color = new THREE.Color(data.domain_colors[p.userData.domain] || '#888888');
                } else {
                    color = new THREE.Color(getClusterColor(p.userData.cluster));
                }
                
                p.material.color.copy(color);
                if (p.vertexPoints) p.vertexPoints.material.color.copy(color);
                if (p.stemLine) p.stemLine.material.color.copy(color);
                if (p.label) p.label.element.style.color = `#${color.getHexString()}`;
            });
        }

        openCatalog.addEventListener('click', () => {
            modalOverlay.style.display = 'flex';
            populateCatalog();
        });

        closeCatalog.addEventListener('click', () => {
            modalOverlay.style.display = 'none';
        });

        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) modalOverlay.style.display = 'none';
        });

        const VIEW_COLORS = {
            distributional: '#3498db',
            topological: '#e74c3c',
            dynamical: '#2ecc71',
            symmetry: '#f39c12',
            scale: '#9b59b6',
            quasicrystal: '#1abc9c',
            other: '#666',
        };

        function populateCatalog() {
            const list = document.getElementById('catalog-list');
            if (list.children.length > 0) return; // Already populated

            if (geometries) {
                geometries.sort((a,b) => a.name.localeCompare(b.name)).forEach(g => {
                    const item = document.createElement('div');
                    const vc = VIEW_COLORS[g.view] || '#666';
                    item.style.cssText = `border-left: 3px solid ${vc}; padding-left: 15px; margin-bottom: 10px;`;
                    const metricsHtml = g.metrics ? `<div style="font-size: 10px; color: #555; margin-top: 4px;">${g.metrics.map(prettifyMetric).join(' · ')}</div>` : '';
                    item.innerHTML = `
                        <div style="display: flex; align-items: baseline; gap: 8px; margin-bottom: 4px;">
                            <span style="color: #fff; font-weight: 700; font-size: 13px;">${g.name}</span>
                            <span style="color: ${vc}; font-size: 9px; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 600;">${g.view}</span>
                        </div>
                        <div style="color: #aaa; font-size: 11px; line-height: 1.5;">${g.description}</div>
                        <div style="color: #777; font-size: 10px; margin-top: 3px; font-style: italic;">Detects: ${g.detects}</div>
                        ${metricsHtml}
                    `;
                    list.appendChild(item);
                });
            }
        }

        // ── Metric Explorer ──────────────────────────────────────────
        const EXPLORER_PRESETS = [
            { name: 'Triality Focus', x: 'D4 Triality:triality_invariance', y: 'G2 Root System:short_long_ratio', z: 'H3 Icosahedral:axis_golden_ratio' },
            { name: 'Entropy Trifecta', x: 'Information Theory:block_entropy_2', y: 'Spectral Analysis:spectral_entropy', z: 'Persistent Homology:persistence_entropy' },
            { name: 'Causal Structure', x: 'Lorentzian:causal_order_preserved', y: 'Recurrence Quantification:determinism', z: 'Attractor Reconstruction:lyapunov_max' },
            { name: 'Fractal Dims', x: 'Attractor Reconstruction:correlation_dimension', y: 'Cantor Set:estimated_dimension', z: 'Hölder Regularity:multifractal_width' },
            { name: 'Orthogonal Structure', x: 'Symplectic:q_spread', y: 'Lorentzian:causal_order_preserved', z: 'Fractal (Mandelbrot):interior_fraction' },
            { name: 'Transport Scales', x: 'Multi-Scale Wasserstein:w_fine', y: 'Multi-Scale Wasserstein:w_coarse', z: 'Multi-Scale Wasserstein:w_slope' },
        ];

        function precomputeZScores() {
            const profiles = data.profiles;
            const nSrc = profiles.length;
            const nMet = profiles[0].length;
            const z = new Float64Array(nSrc * nMet);

            for (let j = 0; j < nMet; j++) {
                let sum = 0, sum2 = 0;
                for (let i = 0; i < nSrc; i++) {
                    const v = profiles[i][j];
                    sum += v;
                    sum2 += v * v;
                }
                const mean = sum / nSrc;
                const std = Math.sqrt(sum2 / nSrc - mean * mean) || 1;
                for (let i = 0; i < nSrc; i++) {
                    let val = (profiles[i][j] - mean) / std;
                    // Clamp to [-5, 5]
                    if (val > 5) val = 5;
                    else if (val < -5) val = -5;
                    z[i * nMet + j] = val;
                }
            }
            return z;
        }

        function computeExplorerPositions(xi, yi, zi) {
            const nMet = data.metric_names.length;
            const spread = atlasScale * 3;
            return data.sources.map((_, i) => [
                explorerZScores[i * nMet + xi] * spread,
                explorerZScores[i * nMet + yi] * spread,
                explorerZScores[i * nMet + zi] * spread
            ]);
        }

        function buildMetricSelectors() {
            const names = data.metric_names;
            // Group by geometry prefix
            const groups = {};
            const groupOrder = [];
            names.forEach((n, idx) => {
                const colon = n.indexOf(':');
                const geo = colon >= 0 ? n.substring(0, colon) : 'Other';
                const met = colon >= 0 ? n.substring(colon + 1) : n;
                if (!groups[geo]) { groups[geo] = []; groupOrder.push(geo); }
                groups[geo].push({ met, idx });
            });

            ['explorer-x', 'explorer-y', 'explorer-z'].forEach(id => {
                const sel = document.getElementById(id);
                sel.innerHTML = '';
                groupOrder.forEach(geo => {
                    const og = document.createElement('optgroup');
                    og.label = geo;
                    groups[geo].forEach(({ met, idx }) => {
                        const opt = document.createElement('option');
                        opt.value = idx;
                        opt.textContent = prettifyMetric(met);
                        sel.appendChild(opt); // append to select first, move to optgroup
                        og.appendChild(opt);
                    });
                    sel.appendChild(og);
                });

                sel.addEventListener('change', () => {
                    if (!explorerActive) return;
                    // Clear preset highlight
                    document.querySelectorAll('.preset-pill').forEach(p => p.classList.remove('active'));
                    applyExplorerMetrics();
                });
            });
        }

        function buildPresetButtons() {
            const container = document.getElementById('preset-pills');
            container.innerHTML = '';
            const nameToIdx = {};
            data.metric_names.forEach((n, i) => nameToIdx[n] = i);

            EXPLORER_PRESETS.forEach(preset => {
                // Only show presets whose metrics exist in the data
                if (!(preset.x in nameToIdx) || !(preset.y in nameToIdx) || !(preset.z in nameToIdx)) return;
                const pill = document.createElement('button');
                pill.className = 'preset-pill';
                pill.textContent = preset.name;
                pill.title = `${preset.x.split(':').pop()}, ${preset.y.split(':').pop()}, ${preset.z.split(':').pop()}`;
                pill.addEventListener('click', () => applyPreset(preset, pill));
                container.appendChild(pill);
            });
        }

        function highlightMatchingPreset() {
            const xi = document.getElementById('explorer-x').value;
            const yi = document.getElementById('explorer-y').value;
            const zi = document.getElementById('explorer-z').value;
            const nameToIdx = {};
            data.metric_names.forEach((n, i) => nameToIdx[n] = String(i));
            document.querySelectorAll('.preset-pill').forEach(pill => {
                const preset = EXPLORER_PRESETS.find(p => p.name === pill.textContent);
                if (preset && nameToIdx[preset.x] === xi && nameToIdx[preset.y] === yi && nameToIdx[preset.z] === zi) {
                    pill.classList.add('active');
                }
            });
        }

        function applyPreset(preset, pill) {
            const nameToIdx = {};
            data.metric_names.forEach((n, i) => nameToIdx[n] = i);

            document.getElementById('explorer-x').value = nameToIdx[preset.x];
            document.getElementById('explorer-y').value = nameToIdx[preset.y];
            document.getElementById('explorer-z').value = nameToIdx[preset.z];

            document.querySelectorAll('.preset-pill').forEach(p => p.classList.remove('active'));
            if (pill) pill.classList.add('active');

            if (!explorerActive) enterExplorer();
            applyExplorerMetrics();
        }

        function enterExplorer() {
            explorerActive = true;
            explorerViewBeforeEnter = currentView;
            // Explorer mode: all sources equally relevant
            sourceRelevance = data.sources.map(() => 1);
            updatePointVisibility();

            document.getElementById('metric-explorer-toggle').classList.add('active');
            document.getElementById('explorer-panel').classList.add('visible');

            // Dim view buttons
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.style.opacity = '0.3';
                btn.style.pointerEvents = 'none';
            });

            // Dim pivot button
            document.getElementById('pivot-axes').style.opacity = '0.3';
            document.getElementById('pivot-axes').style.pointerEvents = 'none';

            // Disable relevance slider (no per-view relevance in explorer)
            relevanceSlider.disabled = true;
            relevanceSlider.style.opacity = '0.3';
        }

        function exitExplorer() {
            if (!explorerActive) return;
            explorerActive = false;

            document.getElementById('metric-explorer-toggle').classList.remove('active');
            document.getElementById('explorer-panel').classList.remove('visible');
            document.querySelectorAll('.preset-pill').forEach(p => p.classList.remove('active'));

            // Restore view buttons
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.style.opacity = '';
                btn.style.pointerEvents = '';
            });
            document.getElementById('pivot-axes').style.opacity = '';
            document.getElementById('pivot-axes').style.pointerEvents = '';

            // Re-enable relevance slider
            relevanceSlider.disabled = false;
            relevanceSlider.style.opacity = '';

            // Animate back to PCA view
            const restoreView = explorerViewBeforeEnter;
            explorerViewBeforeEnter = null;

            // Force currentView to a sentinel so switchView doesn't short-circuit
            currentView = '__explorer__';
            switchView(restoreView);
        }

        function applyExplorerMetrics() {
            if (viewAnimationId) cancelAnimationFrame(viewAnimationId);

            const xi = parseInt(document.getElementById('explorer-x').value);
            const yi = parseInt(document.getElementById('explorer-y').value);
            const zi = parseInt(document.getElementById('explorer-z').value);
            const targetPCs = computeExplorerPositions(xi, yi, zi);

            const startPositions = points.map(p => p.position.clone());
            const duration = 800;
            const startTime = performance.now();

            function animateExplorer(time) {
                const elapsed = time - startTime;
                const t = Math.min(elapsed / duration, 1);
                const ease = t * (2 - t);

                points.forEach((p, i) => {
                    const sx = startPositions[i].x, sy = startPositions[i].y, sz = startPositions[i].z;
                    const tx = targetPCs[i][0], ty = targetPCs[i][1], tz = targetPCs[i][2];
                    p.position.set(sx + (tx - sx) * ease, sy + (ty - sy) * ease, sz + (tz - sz) * ease);
                    if (p.stemLine) {
                        const arr = p.stemLine.geometry.attributes.position.array;
                        arr[0] = p.position.x; arr[1] = p.position.y; arr[2] = p.position.z;
                        arr[3] = p.position.x; arr[5] = p.position.z;
                        p.stemLine.geometry.attributes.position.needsUpdate = true;
                    }
                });

                if (t < 1) {
                    viewAnimationId = requestAnimationFrame(animateExplorer);
                } else {
                    viewAnimationId = null;
                    finishExplorerSwitch(targetPCs, xi, yi, zi);
                }
            }
            viewAnimationId = requestAnimationFrame(animateExplorer);
        }

        function finishExplorerSwitch(targetPCs, xi, yi, zi) {
            // Update source data
            data.sources.forEach((s, i) => { s.pc = [...targetPCs[i]]; });

            // Recompute bounds
            const xs = targetPCs.map(p => p[0]);
            const ys = targetPCs.map(p => p[1]);
            const zs = targetPCs.map(p => p[2]);
            const step = 5;
            const minX = Math.floor((Math.min(...xs) - 5) / step) * step;
            const maxX = Math.ceil((Math.max(...xs) + 5) / step) * step;
            const minY = Math.floor((Math.min(...ys) - 5) / step) * step;
            const maxY = Math.ceil((Math.max(...ys) + 5) / step) * step;
            const minZ = Math.floor((Math.min(...zs) - 5) / step) * step;
            const maxZ = Math.ceil((Math.max(...zs) + 5) / step) * step;

            atlasBounds = { minX, maxX, minY, maxY, minZ, maxZ };
            atlasCenterX = (minX + maxX) / 2;
            atlasCenterZ = (minZ + maxZ) / 2;

            window.pcaRanges = {
                pc1: [Math.min(...xs), Math.max(...xs)],
                pc2: [Math.min(...ys), Math.max(...ys)],
                pc3: [Math.min(...zs), Math.max(...zs)]
            };

            // Set axes to metric names
            const metricLabel = (idx) => {
                const full = data.metric_names[idx];
                const colon = full.indexOf(':');
                const met = colon >= 0 ? full.substring(colon + 1) : full;
                const geo = colon >= 0 ? full.substring(0, colon) : '';
                return geo ? `${prettifyMetric(met)} (${geo})` : prettifyMetric(met);
            };

            data.axes = {
                pc1: { label: `X: ${metricLabel(xi)}`, variance: 0, low: '-5σ', high: '+5σ' },
                pc2: { label: `Y: ${metricLabel(yi)}`, variance: 0, low: '-5σ', high: '+5σ' },
                pc3: { label: `Z: ${metricLabel(zi)}`, variance: 0, low: '-5σ', high: '+5σ' },
            };
            window.atlasAxes = {};

            // Remove + recreate walls and axes
            if (wallXY) scene.remove(wallXY);
            if (wallZY) scene.remove(wallZY);
            if (floor) scene.remove(floor);
            if (axisGroup) axisGroup.clear();
            addWalls(data, atlasBounds);
            addAxisLabels(atlasBounds);

            // Fix stem line floor Y
            points.forEach(p => {
                if (p.stemLine) {
                    const arr = p.stemLine.geometry.attributes.position.array;
                    arr[4] = minY;
                    p.stemLine.geometry.attributes.position.needsUpdate = true;
                }
            });

            rebuildWebs();
            lastCamX = NaN;

            // Update UI labels for explorer mode
            const subtitle = document.getElementById('atlas-subtitle');
            subtitle.innerHTML = '<span style="color:#e67e22">Explorer</span>: direct metric plot (z-scored)';
            ['pc1', 'pc2', 'pc3'].forEach((key, idx) => {
                const metIdx = [xi, yi, zi][idx];
                const el = document.getElementById(`${key}-label`);
                if (el) {
                    const axisName = ['X', 'Y', 'Z'][idx];
                    el.innerHTML = `<span style="color:#e67e22; font-weight:900;">${axisName}</span>: ${metricLabel(metIdx)}`;
                    el.title = `${data.metric_names[metIdx]} (z-score, clamped ±5σ)`;
                }
                document.getElementById(`${key}-min`).textContent = '-5σ';
                document.getElementById(`${key}-max`).textContent = '+5σ';
            });
        }

        async function init() {
            // Scene & Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            scene.fog = new THREE.FogExp2(0x0a0a0a, 0.015);

            axisGroup = new THREE.Group();
            scene.add(axisGroup);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(30, 20, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            labelRenderer.domElement.style.zIndex = '1';
            document.body.appendChild(labelRenderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Load Data
            status.textContent = "Loading data...";
            try {
                const dataResp = await fetch('structure_atlas_data.json');

                if (!dataResp.ok) throw new Error("Atlas data not found");
                data = await dataResp.json();

                // Scale coordinates by 1.25 to make the projection larger
                data.sources.forEach(s => {
                    if (s.pc) s.pc = s.pc.map(v => v * atlasScale);
                });

                // Geometry catalog is embedded in the atlas data
                if (data.geometry_catalog) {
                    geometries = data.geometry_catalog;
                }

                status.textContent = `Rendering ${data.sources.length} sources...`;
                
                // Update dynamic counts in header
                document.getElementById('sourceCount').textContent = data.sources.length;
                const uniqueDomains = new Set(data.sources.map(s => s.domain));
                document.getElementById('domainCount').textContent = uniqueDomains.size;
                document.getElementById('metricCount').textContent = data.n_metrics || '...';
                document.getElementById('geomCount').textContent = geometries ? geometries.length : (data.n_geometries || 33);

                // Initialize visibility
                Object.keys(data.domain_colors).forEach(d => visibleDomains.add(d));
                allClusters = [...new Set(data.sources.map(s => s.cluster))].sort((a, b) => a - b);
                allClusters.forEach(c => visibleClusters.add(c));

                // Save full atlas state for view switching
                pivotIdx = 0;
                const rawPcReload = data.sources.map(s => s.pc.map(v => v / atlasScale));
                baseSpread = meanStd(rawPcReload);
                savedFullAtlas = {
                    pc: data.sources.map(s => [...s.pc]),
                    rawPc: rawPcReload,
                    clusters: data.sources.map(s => s.cluster),
                    allClusters: [...allClusters],
                    axes: data.axes ? JSON.parse(JSON.stringify(data.axes)) : null
                };
                unpermutedAxes = savedFullAtlas.axes;

                // Calculate bounds
                const pc1s = data.sources.map(s => s.pc[0]);
                const pc2s = data.sources.map(s => s.pc[1]);
                const pc3s = data.sources.map(s => s.pc[2]);
                const step = 5;
                const minX = Math.floor((Math.min(...pc1s) - 5) / step) * step;
                const maxX = Math.ceil((Math.max(...pc1s) + 5) / step) * step;
                const minY = Math.floor((Math.min(...pc2s) - 5) / step) * step;
                const maxY = Math.ceil((Math.max(...pc2s) + 5) / step) * step;
                const minZ = Math.floor((Math.min(...pc3s) - 5) / step) * step;
                const maxZ = Math.ceil((Math.max(...pc3s) + 5) / step) * step;

                atlasBounds = { minX, maxX, minY, maxY, minZ, maxZ };
                atlasCenterX = (minX + maxX) / 2;
                atlasCenterZ = (minZ + maxZ) / 2;

                // Update PCA Dashboard Labels
                const rawMinPC1 = Math.min(...pc1s);
                const rawMaxPC1 = Math.max(...pc1s);
                const rawMinPC2 = Math.min(...pc2s);
                const rawMaxPC2 = Math.max(...pc2s);
                const rawMinPC3 = Math.min(...pc3s);
                const rawMaxPC3 = Math.max(...pc3s);

                // Read axis endpoint labels from data (PCA sign varies between runs)
                const axes = data.axes || {};
                document.getElementById('pc1-min').textContent = (axes.pc1 && axes.pc1.low) || 'Low';
                document.getElementById('pc1-max').textContent = (axes.pc1 && axes.pc1.high) || 'High';
                document.getElementById('pc2-min').textContent = (axes.pc2 && axes.pc2.low) || 'Low';
                document.getElementById('pc2-max').textContent = (axes.pc2 && axes.pc2.high) || 'High';
                document.getElementById('pc3-min').textContent = (axes.pc3 && axes.pc3.low) || 'Low';
                document.getElementById('pc3-max').textContent = (axes.pc3 && axes.pc3.high) || 'High';

                window.pcaRanges = {
                    pc1: [rawMinPC1, rawMaxPC1],
                    pc2: [rawMinPC2, rawMaxPC2],
                    pc3: [rawMinPC3, rawMaxPC3]
                };
                window.atlasAxes = data.axes || {};

                // Update PC Labels and Titles (preserving static descriptions)
                if (data.axes) {
                    ['pc1', 'pc2', 'pc3'].forEach((key, idx) => {
                        const ax = data.axes[key];
                        if (ax) {
                            const pct = (ax.variance * 100).toFixed(1);
                            const shortLabel = ax.label.replace(/^PC\d+:\s*/, '');
                            const el = document.getElementById(`${key}-label`);
                            if (el) {
                                // Update text
                                const axisName = ['X', 'Y', 'Z'][idx];
                                el.innerHTML = `<span style="color:#ddd; font-weight:900;">${axisName}</span> <span style="color:#666">/ PC${idx+1}</span>: ${shortLabel} <span style="color:#555">(${pct}%)</span>`;
                                
                                // Update tooltip: preserve original description if present
                                const originalTitle = el.getAttribute('data-original-title') || el.title;
                                if (!el.getAttribute('data-original-title')) {
                                    el.setAttribute('data-original-title', originalTitle);
                                }
                                
                                // Regex to find the variance part "22.5% of variance" or similar
                                // If found, replace it. If not, prepend the new variance.
                                const varianceRegex = /\(\d+(\.\d+)?% of variance\)/;
                                let newTitle;
                                
                                if (varianceRegex.test(originalTitle)) {
                                    newTitle = originalTitle.replace(varianceRegex, `(${pct}% of variance)`);
                                } else {
                                    // If no variance found in string (or it's the dynamic generic one), rebuild it
                                    // If the description is just "First principal component.", append the rest
                                    const descPart = originalTitle.replace(/^(First|Second|Third) principal component\.?/, '').trim();
                                    newTitle = `PC${idx+1} (${pct}% of variance). ${descPart || ax.description}`;
                                }
                                
                                el.title = newTitle;
                            }
                        }
                    });
                }

                // Set camera target to the center of the data
                controls.target.set(atlasCenterX, (minY + maxY) / 2, atlasCenterZ);
                
                // Initialize defaults
                lastCameraPos.copy(camera.position);
                lastCameraTarget.copy(controls.target);

                // Pre-calculate Density Ranks (Per Domain, by Uniqueness/Isolation)
                const sourcesByDomain = {};
                data.sources.forEach(s => {
                    if (!sourcesByDomain[s.domain]) sourcesByDomain[s.domain] = [];
                    sourcesByDomain[s.domain].push(s);
                });
                
                Object.values(sourcesByDomain).forEach(group => {
                    // Sort by nearest neighbor distance (descending) -> Most isolated first
                    group.sort((a, b) => {
                        const distA = (a.neighbors && a.neighbors[0]) ? a.neighbors[0].distance : Infinity;
                        const distB = (b.neighbors && b.neighbors[0]) ? b.neighbors[0].distance : Infinity;
                        // Handle Infinity (put first)
                        if (distA === Infinity && distB !== Infinity) return -1;
                        if (distB === Infinity && distA !== Infinity) return 1;
                        return distB - distA;
                    });
                    
                    // Assign rank (0.0 to 1.0)
                    group.forEach((s, i) => {
                        s.densityRank = i / Math.max(group.length - 1, 1);
                        s.isTopDog = (i === 0); // Always show the most unique one
                    });
                });

                createAtlas(data, atlasBounds.minY);
                addWalls(data, atlasBounds);
                addAxisLabels(atlasBounds);
                createLegend(data);
                buildViewButtons();

                // Explorer mode setup
                if (data.profiles && data.metric_names) {
                    explorerZScores = precomputeZScores();
                    buildMetricSelectors();
                    buildPresetButtons();

                    // Set initial selector values to first preset's metrics
                    const nameToIdx = {};
                    data.metric_names.forEach((n, i) => nameToIdx[n] = i);
                    const firstPreset = EXPLORER_PRESETS.find(p => p.x in nameToIdx && p.y in nameToIdx && p.z in nameToIdx);
                    if (firstPreset) {
                        document.getElementById('explorer-x').value = nameToIdx[firstPreset.x];
                        document.getElementById('explorer-y').value = nameToIdx[firstPreset.y];
                        document.getElementById('explorer-z').value = nameToIdx[firstPreset.z];
                    }

                    document.getElementById('metric-explorer-toggle').addEventListener('click', () => {
                        if (explorerActive) exitExplorer();
                        else { enterExplorer(); highlightMatchingPreset(); applyExplorerMetrics(); }
                    });

                    document.getElementById('explorer-back').addEventListener('click', exitExplorer);
                } else {
                    // No profiles data --- hide the explorer button
                    document.getElementById('metric-explorer-toggle').style.display = 'none';
                }

                // Setup Search Logic
                const clearSearch = document.getElementById('clearSearch');

                function updateSearchNav() {
                    const show = searchMatches.length > 1;
                    searchPrev.style.display = show ? 'inline-block' : 'none';
                    searchNext.style.display = show ? 'inline-block' : 'none';
                    if (searchMatches.length > 0) {
                        searchStatus.textContent = searchMatches.length > 1
                            ? `${searchMatchIdx + 1}/${searchMatches.length}: ${searchMatches[searchMatchIdx].name}`
                            : `Found: ${searchMatches[0].name}`;
                        searchStatus.style.display = 'block';
                        searchStatus.style.color = '#3498db';
                    }
                }

                function searchNavigate(delta) {
                    if (searchMatches.length < 2) return;
                    searchMatchIdx = (searchMatchIdx + delta + searchMatches.length) % searchMatches.length;
                    updateSearchNav();
                    focusOnPoint(searchMatches[searchMatchIdx]);
                }

                searchPrev.addEventListener('click', () => searchNavigate(-1));
                searchNext.addEventListener('click', () => searchNavigate(1));

                searchInput.addEventListener('input', (e) => {
                    const query = e.target.value.toLowerCase().trim();
                    clearSearch.style.display = query ? 'block' : 'none';

                    if (!query) {
                        searchStatus.style.display = 'none';
                        searchPrev.style.display = 'none';
                        searchNext.style.display = 'none';
                        searchMatches = [];
                        searchMatchIdx = -1;
                        currentSearchMatch = null;
                        return;
                    }

                    // Collect all matches: startsWith first, then includes (name + domain)
                    const starts = data.sources.filter(s => s.name.toLowerCase().startsWith(query));
                    const includes = data.sources.filter(s =>
                        !s.name.toLowerCase().startsWith(query) &&
                        (s.name.toLowerCase().includes(query) || s.domain.toLowerCase().includes(query)));
                    searchMatches = [...starts, ...includes];
                    searchMatchIdx = 0;

                    if (searchMatches.length > 0) {
                        updateSearchNav();
                        focusOnPoint(searchMatches[0]);
                    } else {
                        searchStatus.textContent = 'No match found';
                        searchStatus.style.display = 'block';
                        searchStatus.style.color = '#555';
                        searchPrev.style.display = 'none';
                        searchNext.style.display = 'none';
                        currentSearchMatch = null;
                    }
                });

                clearSearch.addEventListener('click', () => {
                    searchInput.value = '';
                    clearSearch.style.display = 'none';
                    searchStatus.style.display = 'none';
                    searchPrev.style.display = 'none';
                    searchNext.style.display = 'none';
                    searchMatches = [];
                    searchMatchIdx = -1;
                    currentSearchMatch = null;
                    searchInput.focus();
                });

                searchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && searchMatches.length > 1) {
                        searchNavigate(e.shiftKey ? -1 : 1);
                        e.preventDefault();
                    } else if (e.key === 'Escape') {
                        clearSearch.click();
                        searchInput.blur();
                    }
                });

                status.textContent = "Ready.";
                document.getElementById('overlay').style.opacity = '0';
                setTimeout(() => document.getElementById('overlay').remove(), 500);
            } catch (e) {
                console.error("Failed to load atlas data:", e);
                status.style.color = "#e74c3c";
                status.textContent = "Error: Data file not found.";
                document.querySelector('.loader').style.borderBottomColor = '#e74c3c';
                document.querySelector('.loader').style.animation = 'none';
            }

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseMove); // Support tap-to-inspect
            window.addEventListener('click', onMouseClick);
            
            document.getElementById('ui-toggle').addEventListener('click', () => {
                document.body.classList.toggle('ui-hidden');
            });
            
            animate();
        }

        function onMouseClick(event) {
            // Ignore clicks on UI elements
            if (event.target.closest('.glass-card') || event.target.closest('#ui-toggle') || event.target.closest('#tooltip')) return;
            
            if (currentHoveredPoint) {
                // Toggle focus if clicking the same point
                if (currentSearchMatch && currentSearchMatch.name === currentHoveredPoint.name) {
                    resetView();
                } else {
                    focusOnPoint(currentHoveredPoint);
                }
            }
        }

        function resetView() {
            if (searchAnimationId) cancelAnimationFrame(searchAnimationId);
            
            currentSearchMatch = null;
            searchMatches = [];
            searchMatchIdx = -1;
            searchStatus.style.display = 'none';
            searchPrev.style.display = 'none';
            searchNext.style.display = 'none';
            document.getElementById('clearSearch').style.display = 'none';
            searchInput.value = '';

            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();
            const endPos = lastCameraPos.clone();
            const endTarget = lastCameraTarget.clone();

            const duration = 800;
            const startTime = performance.now();

            function animateReset(time) {
                const elapsed = time - startTime;
                const t = Math.min(elapsed / duration, 1);
                const ease = t * (2 - t); 
                
                camera.position.lerpVectors(startPos, endPos, ease);
                controls.target.lerpVectors(startTarget, endTarget, ease);
                controls.update();
                
                if (t < 1) {
                    searchAnimationId = requestAnimationFrame(animateReset);
                } else {
                    searchAnimationId = null;
                }
            }
            searchAnimationId = requestAnimationFrame(animateReset);
        }

        function addAxisLabels(b) {
            const axes = data.axes || {};
            const pc1 = axes.pc1 || { label: 'PC1', variance: 0 };
            const pc2 = axes.pc2 || { label: 'PC2', variance: 0 };
            const pc3 = axes.pc3 || { label: 'PC3', variance: 0 };
            const shortName = (ax) => ax.label.replace(/^PC\d+:\s*/, '');

            // Anchor at the min corner of the bounding box
            const origin = new THREE.Vector3(b.minX, b.minY, b.maxZ);
            const arrowLen = Math.min(b.maxX - b.minX, b.maxY - b.minY, b.maxZ - b.minZ) * 0.25;

            const axesDef = [
                { dir: new THREE.Vector3(1, 0, 0), color: '#e74c3c', label: shortName(pc1) },
                { dir: new THREE.Vector3(0, 1, 0), color: '#2ecc71', label: shortName(pc2) },
                { dir: new THREE.Vector3(0, 0, -1), color: '#3498db', label: shortName(pc3) },
            ];

            axesDef.forEach(({ dir, color, label }) => {
                const tip = origin.clone().addScaledVector(dir, arrowLen);

                // Shaft
                const shaftGeo = new THREE.BufferGeometry().setFromPoints([origin, tip]);
                const shaftMat = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.8 });
                axisGroup.add(new THREE.Line(shaftGeo, shaftMat));

                // Arrowhead cone
                const coneLen = arrowLen * 0.15;
                const coneRad = arrowLen * 0.04;
                const coneGeo = new THREE.ConeGeometry(coneRad, coneLen, 8);
                const coneMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.8 });
                const cone = new THREE.Mesh(coneGeo, coneMat);
                cone.position.copy(tip.clone().addScaledVector(dir, coneLen * 0.5));
                // Orient cone along direction
                const up = new THREE.Vector3(0, 1, 0);
                const quat = new THREE.Quaternion().setFromUnitVectors(up, dir);
                cone.quaternion.copy(quat);
                axisGroup.add(cone);

                // Label at tip
                const div = document.createElement('div');
                div.style.cssText = `color: ${color}; font-size: 10px; font-weight: 700; letter-spacing: 0.05em; white-space: nowrap; pointer-events: none; text-shadow: 0 0 6px rgba(0,0,0,0.9);`;
                div.textContent = label;
                const labelObj = new CSS2DObject(div);
                labelObj.position.copy(tip.clone().addScaledVector(dir, coneLen * 1.5));
                axisGroup.add(labelObj);
            });
        }

        function createCustomGrid(w, h, step, color1, color2) {
            const pts = [];
            const colors = [];
            const c1 = new THREE.Color(color1);
            const c2 = new THREE.Color(color2);

            for (let i = 0; i <= w + 0.001; i += step) {
                pts.push(new THREE.Vector3(i, 0, 0), new THREE.Vector3(i, h, 0));
                const c = (Math.abs(i) < 0.1 || Math.abs(i - w) < 0.1) ? c1 : c2;
                colors.push(c.r, c.g, c.b, c.r, c.g, c.b);
            }
            for (let j = 0; j <= h + 0.001; j += step) {
                pts.push(new THREE.Vector3(0, j, 0), new THREE.Vector3(w, j, 0));
                const c = (Math.abs(j) < 0.1 || Math.abs(j - h) < 0.1) ? c1 : c2;
                colors.push(c.r, c.g, c.b, c.r, c.g, c.b);
            }

            const geo = new THREE.BufferGeometry().setFromPoints(pts);
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const mat = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.7 });
            return new THREE.LineSegments(geo, mat);
        }

        function addWalls(data, b) {
            const step = 5;
            const sizeX = b.maxX - b.minX;
            const sizeY = b.maxY - b.minY;
            const sizeZ = b.maxZ - b.minZ;

            const edgeColor = 0x888888;
            const gridColor = 0x333333;

            // Wall XY (Back/Front) - Vertical Plane
            wallXY = createCustomGrid(sizeX, sizeY, step, edgeColor, gridColor);
            scene.add(wallXY);

            // Wall ZY (Left/Right) - Vertical Plane
            wallZY = createCustomGrid(sizeZ, sizeY, step, edgeColor, gridColor);
            wallZY.rotation.y = Math.PI / 2;
            scene.add(wallZY);
            
            // Floor XZ - Horizontal Plane
            floor = createCustomGrid(sizeX, sizeZ, step, edgeColor, gridColor);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(b.minX, b.minY, b.maxZ);
            scene.add(floor);
        }

        function updateWalls() {
            if (!wallXY || !camera || !atlasBounds) return;

            const b = atlasBounds;

            // Wall XY: spans minX->maxX, minY->maxY. Only moves in Z.
            // It sits at the Z boundary furthest from the camera.
            wallXY.position.set(b.minX, b.minY, (camera.position.z > atlasCenterZ) ? b.minZ : b.maxZ);
            wallXY.rotation.y = 0;
            wallXY.scale.x = 1;

            // Wall ZY: spans minZ->maxZ, minY->maxY. Only moves in X.
            // Rotated PI/2 Y makes local X -> world Z.
            // It sits at the X boundary furthest from the camera.
            wallZY.position.set((camera.position.x > atlasCenterX) ? b.minX : b.maxX, b.minY, b.maxZ);
            wallZY.rotation.y = Math.PI / 2;
            wallZY.scale.x = 1;
        }

        function updateLabels() {
            const camPos = camera.position;
            for (let i = 0, n = points.length; i < n; i++) {
                const p = points[i];
                if (!p.label) continue;
                const isVisible = visibleDomains.has(p.userData.domain) && visibleClusters.has(p.userData.cluster);
                if (!isVisible) {
                    if (p.label.visible) p.label.visible = false;
                    continue;
                }
                const dx = camPos.x - p.position.x, dy = camPos.y - p.position.y, dz = camPos.z - p.position.z;
                const d = Math.sqrt(dx*dx + dy*dy + dz*dz);
                const inRange = d < labelThreshold;
                if (!inRange) {
                    if (p.label.visible) p.label.visible = false;
                    continue;
                }
                if (!p.label.visible) p.label.visible = true;
                const factor = Math.pow(1.0 - d / labelThreshold, 1.2);
                const el = p.label.element;
                el.style.fontSize = (10 + factor * 15) + 'px';
                el.style.opacity = 0.4 + factor * 0.6;
                el.style.zIndex = Math.floor(1000 - d);
            }
        }

        function updatePointVisibility() {
            points.forEach((p, i) => {
                let isVisible = visibleDomains.has(p.userData.domain) &&
                                visibleClusters.has(p.userData.cluster) &&
                                (p.userData.densityRank <= densityThreshold || p.userData.isTopDog);

                // Relevance filter: hide sources below threshold
                if (isVisible && relevanceThreshold > 0 && sourceRelevance.length > 0) {
                    const rel = sourceRelevance[i] || 0;
                    if (rel < relevanceThreshold) isVisible = false;
                }

                p.visible = isVisible;
                if (p.stemLine) p.stemLine.visible = isVisible && showStemLines;
            });
            updateWebVisibility();
        }

        function createAtlas(data, floorY) {
            const domainColors = data.domain_colors;
            const pointsByDomain = {};
            const pointsByCluster = {};
            
            data.sources.forEach((source, i) => {
                const [x, y, z] = source.pc;
                const color = new THREE.Color(domainColors[source.domain] || '#888888');
                
                if (!pointsByDomain[source.domain]) pointsByDomain[source.domain] = [];
                if (!pointsByCluster[source.cluster]) pointsByCluster[source.cluster] = [];
                
                // 1. The visible volume (Faint Body) --- shared geometry
                const material = new THREE.MeshBasicMaterial({
                    color: color, transparent: true, opacity: 0.15,
                    depthWrite: false, blending: THREE.AdditiveBlending
                });
                const sphere = new THREE.Mesh(sharedSphereGeo, material);
                sphere.position.set(x, y, z);
                sphere.userData = source;
                scene.add(sphere);
                points.push(sphere);

                // 2. Vertex Points (Technical detail) --- shared geometry
                const pMaterial = new THREE.PointsMaterial({
                    color: color, size: 0.05, transparent: true, opacity: 0.8,
                    depthWrite: false
                });
                const pMesh = new THREE.Points(sharedSphereGeo, pMaterial);
                sphere.add(pMesh);
                sphere.vertexPoints = pMesh;

                // 3. Invisible Hit-Test Mesh --- shared geometry, layer 1 for raycaster
                const hitMat = new THREE.MeshBasicMaterial({ visible: false });
                const hitMesh = new THREE.Mesh(sharedHitGeo, hitMat);
                hitMesh.layers.set(1);
                sphere.add(hitMesh);
                hitMesh.userData = source; // Duplicate data for the raycaster
                pointsByDomain[source.domain].push(sphere.position);
                pointsByCluster[source.cluster].push(sphere.position);

                // Stem Line
                const lineGeo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(x, y, z),
                    new THREE.Vector3(x, floorY, z)
                ]);
                const lineMat = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.2, depthWrite: false });
                const line = new THREE.Line(lineGeo, lineMat);
                scene.add(line);
                sphere.stemLine = line;

                // Label
                const div = document.createElement('div');
                div.className = 'label';
                div.textContent = source.name;
                div.style.color = domainColors[source.domain];
                const label = new CSS2DObject(div);
                label.position.set(0, 0.7, 0);
                sphere.add(label);
                sphere.label = label;
            });

            // Create Domain Webs
            Object.keys(pointsByDomain).forEach(domain => {
                const positions = pointsByDomain[domain];
                if (positions.length < 2) return;
                const linePts = [];
                for (let i = 0; i < positions.length; i++) {
                    for (let j = i + 1; j < positions.length; j++) {
                        linePts.push(positions[i].clone(), positions[j].clone());
                    }
                }
                const webGeo = new THREE.BufferGeometry().setFromPoints(linePts);
                const webMat = new THREE.LineBasicMaterial({ 
                    color: domainColors[domain], transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending 
                });
                const web = new THREE.LineSegments(webGeo, webMat);
                web.visible = false;
                scene.add(web);
                domainWebs[domain] = web;
            });

            // Create Cluster Webs
            Object.keys(pointsByCluster).forEach((cluster, idx) => {
                const positions = pointsByCluster[cluster];
                if (positions.length < 2) return;
                const linePts = [];
                for (let i = 0; i < positions.length; i++) {
                    for (let j = i + 1; j < positions.length; j++) {
                        linePts.push(positions[i].clone(), positions[j].clone());
                    }
                }
                const webGeo = new THREE.BufferGeometry().setFromPoints(linePts);
                const webMat = new THREE.LineBasicMaterial({ 
                    color: getClusterColor(cluster), 
                    transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending 
                });
                const web = new THREE.LineSegments(webGeo, webMat);
                web.visible = false;
                scene.add(web);
                clusterWebs[cluster] = web;
            });
        }

        function updateWebVisibility() {
            Object.keys(domainWebs).forEach(d => {
                domainWebs[d].visible = showDomainWebs && visibleDomains.has(d);
            });
            Object.keys(clusterWebs).forEach(c => {
                clusterWebs[c].visible = showClusterWebs && visibleClusters.has(parseInt(c));
            });
        }

        function createLegend(data) {
            const container = document.getElementById('legend');
            container.innerHTML = '';
            
            // --- Domains Section ---
            const domHeader = document.createElement('div');
            domHeader.className = 'legend-title';
            domHeader.textContent = 'Data Domains';
            domHeader.title = 'Category of origin for each data source. Click to solo; shift-click to toggle visibility.';
            container.appendChild(domHeader);

            const domSection = document.createElement('div');
            domSection.className = 'legend-section';
            container.appendChild(domSection);

            const sortedDomains = Object.keys(data.domain_colors).sort();
            
            // Calculate domain counts
            const domainCounts = {};
            data.sources.forEach(s => {
                domainCounts[s.domain] = (domainCounts[s.domain] || 0) + 1;
            });

            sortedDomains.forEach(domain => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.style.cssText = 'cursor: pointer; transition: opacity 0.2s;';
                const count = domainCounts[domain] || 0;
                item.innerHTML = `
                    <div class="legend-color" style="background: ${data.domain_colors[domain]}"></div>
                    <div style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${domain.replace('_', ' ')} <span style="color:#666; font-size:9px;">(${count})</span></div>
                `;
                
                item.addEventListener('click', (e) => {
                    if (!e.shiftKey) {
                        const isSolo = visibleDomains.size === 1 && visibleDomains.has(domain);
                        visibleDomains.clear();
                        if (isSolo) sortedDomains.forEach(d => visibleDomains.add(d));
                        else visibleDomains.add(domain);
                        Array.from(domSection.children).forEach((el, i) => {
                            el.style.opacity = visibleDomains.has(sortedDomains[i]) ? '1.0' : '0.25';
                        });
                    } else {
                        if (visibleDomains.has(domain)) visibleDomains.delete(domain);
                        else visibleDomains.add(domain);
                        item.style.opacity = visibleDomains.has(domain) ? '1.0' : '0.25';
                    }
                    updatePointVisibility();
                });
                domSection.appendChild(item);
            });

            // --- Clusters Section ---
            const clHeader = document.createElement('div');
            clHeader.className = 'legend-title';
            clHeader.textContent = 'Geometric Clusters';
            const nMet = currentView && data.views[currentView] ? data.views[currentView].n_metrics : (data.n_metrics || '?');
            const viewNote = currentView ? ` (${currentView} lens)` : '';
            clHeader.title = `Groups of sources with similar structural fingerprints across ${nMet} metrics${viewNote}, found by hierarchical clustering. Click to solo; shift-click to toggle visibility.`;
            container.appendChild(clHeader);

            const clSection = document.createElement('div');
            clSection.className = 'legend-section';
            container.appendChild(clSection);

            const clusterPalette = ['#e67e22', '#f1c40f', '#2ecc71', '#3498db', '#9b59b6', '#1abc9c', '#e74c3c', '#fd79a8'];
            const allClusters = [...new Set(data.sources.map(s => s.cluster))].sort((a,b)=>a-b);
            
            allClusters.forEach((cId, idx) => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.style.cssText = 'cursor: pointer; transition: opacity 0.2s;';
                const color = getClusterColor(cId);
                const viewClusters = currentView && data.views[currentView] && data.views[currentView].clusters;
                const cInfo = (viewClusters && viewClusters[String(cId)]) || (data.clusters && data.clusters[String(cId)]);
                const cLabel = cInfo && cInfo.label ? cInfo.label : `Cluster ${cId}`;
                item.innerHTML = `
                    <div class="legend-color" style="background: ${color}; border-radius: 50%;"></div>
                    <div style="overflow:hidden; text-overflow:ellipsis; white-space:nowrap;" title="${cInfo ? cInfo.members.join(', ') : ''}">${cLabel}</div>
                `;
                
                item.addEventListener('click', (e) => {
                    if (!e.shiftKey) {
                        const isSolo = visibleClusters.size === 1 && visibleClusters.has(cId);
                        visibleClusters.clear();
                        if (isSolo) allClusters.forEach(c => visibleClusters.add(c));
                        else visibleClusters.add(cId);
                        Array.from(clSection.children).forEach((el, i) => {
                            el.style.opacity = visibleClusters.has(allClusters[i]) ? '1.0' : '0.25';
                        });
                    } else {
                        if (visibleClusters.has(cId)) visibleClusters.delete(cId);
                        else visibleClusters.add(cId);
                        item.style.opacity = visibleClusters.has(cId) ? '1.0' : '0.25';
                    }
                    updatePointVisibility();
                });
                clSection.appendChild(item);
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            // Throttle to one raycast per rAF
            pendingMouseEvent = event;
            if (mouseMoveRafPending) return;
            mouseMoveRafPending = true;
            requestAnimationFrame(() => {
                mouseMoveRafPending = false;
                if (pendingMouseEvent) _doMouseMove(pendingMouseEvent);
            });
        }

        function _doMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            raycaster.layers.set(1); // Only test hit-test meshes on layer 1
            const allIntersects = raycaster.intersectObjects(points, true);
            raycaster.layers.set(0); // Reset to default
            const intersects = allIntersects.filter(hit => {
                return hit.object.parent ? hit.object.parent.visible : hit.object.visible;
            });

            if (!cachedTooltipEl) cachedTooltipEl = document.getElementById('tooltip');
            const tooltip = cachedTooltipEl;
            if (intersects.length > 0) {
                // Get data from the hit object or its parent
                const obj = intersects[0].object;
                const s = obj.userData.name ? obj.userData : obj.parent.userData;
                
                if (s && s.name) {
                    document.body.style.cursor = 'pointer';
                    tooltip.style.left = (event.clientX + 15) + 'px';
                    tooltip.style.top = (event.clientY + 15) + 'px';

                    // Skip full rebuild if still hovering same source
                    if (lastHoveredName === s.name) {
                        // Just reposition
                        const tr = tooltip.getBoundingClientRect();
                        if (tr.right > window.innerWidth) tooltip.style.left = (event.clientX - tr.width - 15) + 'px';
                        if (tr.bottom > window.innerHeight) tooltip.style.top = (event.clientY - tr.height - 15) + 'px';
                        currentHoveredPoint = obj.userData.name ? obj.userData : obj.parent.userData;
                        return;
                    }
                    lastHoveredName = s.name;

                    tooltip.style.display = 'block';
                    tooltip.offsetHeight;
                    tooltip.style.opacity = '1';
                    tooltip.style.transform = 'scale(1)';

                    // Description
                    const desc = s.description
                        ? `<div style="color:#888; font-style:italic; margin-bottom:6px; max-width:280px;">${s.description}</div>`
                        : '';

                    // Sequential structure bar
                    let seqHtml = '';
                    if (s.seq_fraction != null) {
                        const pct = (s.seq_fraction * 100).toFixed(0);
                        seqHtml = `
                            <div style="margin-top:6px;">
                                <div style="font-size:10px; color:#777;" title="Fraction of the ${data.n_metrics || '?'} geometric metrics that change significantly when byte order is randomized. 0% = no metric detects ordering (purely distributional). Higher values mean more metrics are sensitive to sequential structure.">Sequential structure: ${pct}%</div>
                                <div style="margin-top:2px; height:4px; background:#222; border-radius:2px; overflow:hidden;">
                                    <div style="width:${pct}%; height:100%; background: linear-gradient(90deg, #3498db, #e74c3c);"></div>
                                </div>
                            </div>`;
                    }

                    // Nearest neighbors
                    let neighborsHtml = '';
                    if (s.neighbors && s.neighbors.length > 0) {
                        const items = s.neighbors.map(n => {
                            const c = n.cross_domain ? '#e67e22' : '#666';
                            const arrow = n.cross_domain ? '\u2192' : '\u00b7';
                            return `<div style="color:${c}; font-size:10px;">${arrow} ${n.name} <span style="color:#555">(${n.distance.toFixed(2)})</span></div>`;
                        }).join('');
                        neighborsHtml = `<div style="margin-top:6px; border-top:1px solid #333; padding-top:4px;">
                            <div style="font-size:9px; color:#555; text-transform:uppercase; letter-spacing:0.05em; margin-bottom:2px;" title="Three closest sources in the full ${data.n_metrics || '?'}-metric space (rank-normalized distance). Orange arrows mark cross-domain neighbors \u2014 structurally similar data from different origins.">Nearest neighbors</div>
                            ${items}</div>`;
                    }

                    // Axis labels from metadata
                    const axLabel = (key, idx) => {
                        const ax = data.axes && data.axes[key];
                        const short = ax ? ax.label.replace(/^PC\d+:\s*/, '').replace(/^[XYZ]:\s*/, '') : `PC${idx+1}`;
                        return short;
                    };

                    // In explorer mode, show z-score values; in PCA mode, show raw PC coords
                    let coordHtml;
                    if (explorerActive && explorerZScores) {
                        const si = points.findIndex(p => p.userData === s);
                        const nMet = data.metric_names.length;
                        const xi = parseInt(document.getElementById('explorer-x').value);
                        const yi = parseInt(document.getElementById('explorer-y').value);
                        const zi = parseInt(document.getElementById('explorer-z').value);
                        const zx = si >= 0 ? explorerZScores[si * nMet + xi].toFixed(2) : '?';
                        const zy = si >= 0 ? explorerZScores[si * nMet + yi].toFixed(2) : '?';
                        const zz = si >= 0 ? explorerZScores[si * nMet + zi].toFixed(2) : '?';
                        coordHtml = `<div style="font-size:10px; color:#aaa;">${axLabel('pc1',0)}: ${zx}σ &nbsp; ${axLabel('pc2',1)}: ${zy}σ &nbsp; ${axLabel('pc3',2)}: ${zz}σ</div>`;
                    } else {
                        coordHtml = `<div style="font-size:10px; color:#aaa;">${axLabel('pc1',0)}: ${s.pc[0].toFixed(1)} &nbsp; ${axLabel('pc2',1)}: ${s.pc[1].toFixed(1)} &nbsp; ${axLabel('pc3',2)}: ${s.pc[2].toFixed(1)}</div>`;
                    }

                    tooltip.innerHTML = `
                        <h3 style="margin:0 0 2px;">${s.name}</h3>
                        <div style="color:#666; font-size:10px; margin-bottom:4px;">${s.domain} &middot; ${(data.clusters && data.clusters[String(s.cluster)] && data.clusters[String(s.cluster)].label) || 'cluster ' + s.cluster}</div>
                        ${desc}
                        ${coordHtml}
                        ${seqHtml}
                        ${neighborsHtml}
                    `;

                    // Update PCA Dashboard
                    const charLabel = document.getElementById('char-label');
                    const updatePointer = (id, val, range) => {
                        const ptr = document.getElementById(id);
                        let pct = ((val - range[0]) / (range[1] - range[0])) * 100;
                        pct = Math.max(0, Math.min(100, pct));
                        ptr.style.left = `${pct}%`;
                        return pct;
                    };

                    const pct1 = updatePointer('pc1-pointer', s.pc[0], window.pcaRanges.pc1);
                    const pct2 = updatePointer('pc2-pointer', s.pc[1], window.pcaRanges.pc2);
                    const pct3 = updatePointer('pc3-pointer', s.pc[2], window.pcaRanges.pc3);
                    
                    // Character type from axis endpoints (adapts to PCA sign)
                    const ax = window.atlasAxes || {};
                    let charType = "Balanced Structure";
                    if (pct1 < 25) charType = (ax.pc1 && ax.pc1.low) || "Low PC1";
                    else if (pct1 > 75) charType = (ax.pc1 && ax.pc1.high) || "High PC1";
                    else if (pct2 < 25) charType = (ax.pc2 && ax.pc2.low) || "Low PC2";
                    else if (pct2 > 75) charType = (ax.pc2 && ax.pc2.high) || "High PC2";
                    
                    charLabel.textContent = `${s.name}: ${charType}`;
                    charLabel.style.color = "#fff";

                    // Keep tooltip on screen
                    const tr = tooltip.getBoundingClientRect();
                    if (tr.right > window.innerWidth) tooltip.style.left = (event.clientX - tr.width - 15) + 'px';
                    if (tr.bottom > window.innerHeight) tooltip.style.top = (event.clientY - tr.height - 15) + 'px';

                    // Scale the parent group
                    currentHoveredPoint = obj.userData.name ? obj.userData : obj.parent.userData;
                }
            } else {
                document.body.style.cursor = 'default';
                tooltip.style.opacity = '0';
                tooltip.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    if (tooltip.style.opacity === '0') tooltip.style.display = 'none';
                }, 100);
                currentHoveredPoint = null;
                lastHoveredName = null;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Only update walls/labels when camera moves
            const cx = camera.position.x, cy = camera.position.y, cz = camera.position.z;
            const cameraMoved = cx !== lastCamX || cy !== lastCamY || cz !== lastCamZ;
            if (cameraMoved) {
                lastCamX = cx; lastCamY = cy; lastCamZ = cz;
                updateWalls();
                updateLabels();
            }

            updateScales();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        function updateScales() {
            const searchName = currentSearchMatch ? currentSearchMatch.name : null;
            const hoverName = currentHoveredPoint ? currentHoveredPoint.name : null;
            for (let i = 0, n = points.length; i < n; i++) {
                const p = points[i];
                let targetScale = 1.0;
                const name = p.userData.name;
                if (searchName === name) targetScale = 4.0;
                if (hoverName === name) targetScale = Math.max(targetScale, 1.5);

                const s = p.scale.x;
                const diff = targetScale - s;
                if (diff > 0.01 || diff < -0.01) {
                    const nextS = s + diff * 0.15;
                    p.scale.set(nextS, nextS, nextS);
                } else if (s !== targetScale) {
                    p.scale.set(targetScale, targetScale, targetScale);
                }
            }
        }

        init();
    </script>
</body>
</html>
